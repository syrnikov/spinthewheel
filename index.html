<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Prize Wheel</title>

  <!-- Google Font: Montserrat -->
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;600;700&display=swap" rel="stylesheet">

  <style>
    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      height: 100%;
      font-family: "Montserrat", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f9;
    }

    body {
      display: flex;
      align-items: stretch;
      justify-content: center;
    }

    .app {
      display: flex;
      flex: 1;
      max-width: 1400px;
      padding: 16px;
      gap: 16px;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      position: relative;
      z-index: 1;
    }

    .wheel-area {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .wheel-wrapper {
      --wheel-zoom: 1;
      position: relative;
      width: min(80vmin, 700px);
      height: min(80vmin, 700px);
      cursor: pointer;
      border-radius: 50%;
      box-shadow: 0 18px 45px rgba(0,0,0,0.22);
      transition: transform 0.25s ease-out, box-shadow 0.25s ease-out;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.55), transparent 60%);
      transform: scale(var(--wheel-zoom));
      transform-origin: center center;
      overflow: visible;
    }

    .wheel-wrapper.spin-anim {
      transform: scale(calc(var(--wheel-zoom) * 1.03));
      box-shadow: 0 24px 60px rgba(0,0,0,0.30);
    }

    canvas {
  width: 100%;
  height: 100%;
  display: block;
  /* no border-radius here */
}


    #wheelCanvas {
      position: relative;
      z-index: 1;
    }

    /* FULLSCREEN CONFETTI OVERLAY */
    #confettiCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 900;
    }

    .pointer {
      position: absolute;
      top: 50%;
      right: -6px; /* close to wheel */
      transform: translateY(-50%);
      width: 0;
      height: 0;
      border-top: 18px solid transparent;
      border-bottom: 18px solid transparent;
      border-right: 28px solid #333; /* arrow points left */
      border-left: 0;
      z-index: 3;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,0.45));
    }

    .panel {
      width: 380px;
      max-width: 40%;
      background: rgba(255,255,255,0.97);
      border-radius: 16px;
      padding: 16px 18px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.08);
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 2;
      backdrop-filter: blur(6px);
      max-height: 100vh;
      overflow: auto;
    }

    .panel h2 {
      margin: 0 0 4px;
      font-size: 1.1rem;
    }

    .panel small {
      font-size: 0.75rem;
      color: #555;
    }

    label {
      font-size: 0.8rem;
      font-weight: 600;
      margin-bottom: 4px;
      display: block;
    }

    input[type="text"],
    input[type="url"] {
      width: 100%;
      font-size: 0.8rem;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #ccc;
      font-family: inherit;
    }

    input[type="color"] {
      width: 60px;
      height: 28px;
      padding: 0;
      border-radius: 999px;
      border: 1px solid #ccc;
      background: transparent;
      cursor: pointer;
    }

    input[type="file"] {
      width: 100%;
      font-size: 0.8rem;
    }

    .panel button {
      padding: 8px 14px;
      font-size: 0.85rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: #111;
      color: #fff;
      align-self: flex-start;
      letter-spacing: 0.02em;
    }

    .panel button:hover {
      opacity: 0.9;
    }

    .panel-row {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .panel .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 4px;
    }

    .toggle-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .toggle-row input {
      width: auto;
    }

    .sectors-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 4px;
    }

    .sector-card {
      border-radius: 10px;
      padding: 8px 10px;
      border: 1px solid #e0e0e0;
      background: #fafafa;
      display: flex;
      flex-direction: column;
      gap: 6px;
      position: relative;
    }

    .sector-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.8rem;
      font-weight: 600;
    }

    .sector-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.75rem;
    }

    .sector-actions {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .sector-color-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,0.2);
      background: #ccc;
    }

    .collapse-toggle,
    .drag-handle {
      background: transparent;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 0.8rem;
      cursor: pointer;
      color: #444;
    }

    .drag-handle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      gap: 4px;
    }

    .sector-card.collapsed .sector-body {
      display: none;
    }

    .sector-body {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .sector-card.drag-over {
      border-color: #111;
      box-shadow: inset 0 0 0 1px #111;
    }

    .sector-delete {
      background: transparent;
      color: #777;
      font-size: 0.9rem;
      border: none;
      cursor: pointer;
      padding: 2px 6px;
    }

    .sector-delete[disabled] {
      opacity: 0.4;
      cursor: default;
    }

    .sector-delete:hover:not([disabled]) {
      color: #000;
    }

    .sector-row-inline {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .sector-row-inline > div {
      flex: 1;
    }

    .sector-image-preview {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      border: 1px solid #ddd;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      flex-shrink: 0;
    }

    .sector-image-wrapper {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sector-link-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .link-toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 500;
      font-size: 0.75rem;
    }

    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .zoom-controls input[type="range"] {
      flex: 1;
      min-width: 140px;
    }

    .zoom-value {
      font-size: 0.8rem;
      font-weight: 600;
    }

    .hidden {
      display: none !important;
    }

    /* Result modal */
    .result-modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .result-modal__backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.45);
    }

    .result-modal__content {
      position: relative;
      background: #ffffff;
      border-radius: 16px;
      padding: 20px 24px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.25);
      max-width: 320px;
      text-align: center;
      z-index: 1;
      transform: translateY(10px) scale(0.96);
      opacity: 0;
      animation: popup-in 0.25s ease-out forwards;
    }

    .result-modal__content h3 {
      margin: 0 0 8px;
      font-size: 1.1rem;
    }

    .result-modal__content p {
      margin: 0 0 12px;
      font-size: 0.95rem;
    }

    .result-modal__content a {
      display: inline-block;
      margin-bottom: 12px;
      font-size: 0.9rem;
      text-decoration: underline;
      color: #111;
      word-break: break-all;
    }

    .result-modal__content button {
      padding: 8px 18px;
      border-radius: 999px;
      border: none;
      background: #111;
      color: #fff;
      cursor: pointer;
      font-size: 0.9rem;
      letter-spacing: 0.02em;
    }

    .result-modal__content button:hover {
      opacity: 0.9;
    }

    @keyframes popup-in {
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @media (max-width: 900px) {
      .app {
        flex-direction: column;
      }
      .panel {
        width: 100%;
        max-width: 100%;
        order: -1;
      }

    }
  </style>
</head>
<body>
<div class="app">
  <div class="wheel-area" id="wheelArea">
    <div class="wheel-wrapper" id="wheelWrapper">
      <!-- increased canvas size to give room for pop-out images -->
      <canvas id="wheelCanvas" width="1200" height="1200"></canvas>
      <div class="pointer"></div>
    </div>
  </div>

  <div class="panel" id="settingsPanel">
    <div class="panel-row">
      <h2>Prize wheel</h2>
      <small>Click the wheel to spin. Configure each sector below.</small>
    </div>

    <div class="panel-row">
      <label class="toggle-row">
        <input type="checkbox" id="showImagesToggle" checked>
        Show prize images on sectors
      </label>
    </div>

    <div class="panel-row">
      <label for="zoomSlider">Wheel zoom</label>
      <div class="zoom-controls">
        <button type="button" class="zoom-btn" data-delta="-0.05">−</button>
        <input type="range" id="zoomSlider" min="0.7" max="1.3" step="0.05" value="1">
        <button type="button" class="zoom-btn" data-delta="0.05">+</button>
        <span class="zoom-value" id="zoomValue">100%</span>
      </div>
    </div>

    <div class="panel-row">
      <div class="sectors-container" id="sectorsContainer"></div>
      <div class="btn-row">
        <button id="addSectorBtn">+ Add sector</button>
      </div>
    </div>

    <div class="panel-row">
      <label for="logoInput">Center logo (optional)</label>
      <input type="file" id="logoInput" accept="image/*">
    </div>

    <div class="panel-row">
      <label for="bgInput">Background image (optional)</label>
      <input type="file" id="bgInput" accept="image/*">
    </div>

    <div class="panel-row">
      <label>Config</label>
      <div class="btn-row">
        <button id="exportBtn">Export config</button>
        <button id="importBtn">Import config</button>
      </div>
      <input type="file" id="importInput" accept="application/json" style="display:none">
    </div>

    <div class="panel-row">
      <button id="fullscreenBtn">Fullscreen</button>
    </div>
  </div>

  <!-- CONFETTI & RESULT MODAL INSIDE .app (so they show in fullscreen) -->
  <canvas id="confettiCanvas"></canvas>

  <div id="resultModal" class="result-modal hidden">
    <div id="resultBackdrop" class="result-modal__backdrop"></div>
    <div class="result-modal__content">
      <h3 id="resultTitle">You got:</h3>
      <p id="resultText"></p>
      <a id="resultLink" href="#" target="_blank" rel="noopener noreferrer">Open prize page</a><br>
      <button id="resultClose">OK</button>
    </div>
  </div>
</div>

<script>
  const FONT_SPEC = "600 26px 'Montserrat', system-ui";

  const defaultSegmentsData = [
    { label: "Blum hardware pack", url: "https://example.com/blum",  color: "#ff4b4b" },
    { label: "Hinge upgrade",      url: "https://example.com/hinges",color: "#ffb347" },
    { label: "Lighting pack",      url: "https://example.com/lighting", color: "#ffe66d" },
    { label: "Worktop voucher",    url: "https://example.com/worktop", color: "#7bd389" },
    { label: "Kitchen consult",    url: "https://example.com/consult", color: "#4f98ca" },
    { label: "Accessory set",      url: "https://example.com/accessories", color: "#b084f4" },
    { label: "Mystery prize",      url: "https://example.com/mystery", color: "#ff6fb5" }
  ];

  const colorPalette = [
    "#ff4b4b", "#ffb347", "#ffe66d", "#7bd389",
    "#4f98ca", "#b084f4", "#ff6fb5", "#ffa3a3"
  ];

  // state
  let segments = []; // {label,url,color,imageDataUrl,imageObj,linkEnabled,collapsed}
  let showImages = true;
  let logoImg = null;
  let logoDataUrl = null;
  let bgDataUrl = null;
  let wheelZoom = 1;

  const canvas   = document.getElementById("wheelCanvas");
  const ctx      = canvas.getContext("2d");

  const confettiCanvas = document.getElementById("confettiCanvas");
  const confettiCtx    = confettiCanvas.getContext("2d");

  const appEl          = document.querySelector(".app");
  const wheelWrapper   = document.getElementById("wheelWrapper");
  const settingsPanel  = document.getElementById("settingsPanel");

  const sectorsContainer = document.getElementById("sectorsContainer");
  const addSectorBtn     = document.getElementById("addSectorBtn");
  const showImagesToggle = document.getElementById("showImagesToggle");
  const logoInput        = document.getElementById("logoInput");
  const bgInput          = document.getElementById("bgInput");
  const exportBtn        = document.getElementById("exportBtn");
  const importBtn        = document.getElementById("importBtn");
  const importInput      = document.getElementById("importInput");
  const fullscreenBtn    = document.getElementById("fullscreenBtn");
  const zoomSlider       = document.getElementById("zoomSlider");
  const zoomValue        = document.getElementById("zoomValue");
  const zoomButtons      = document.querySelectorAll(".zoom-btn");

  const resultModal     = document.getElementById("resultModal");
  const resultBackdrop  = document.getElementById("resultBackdrop");
  const resultTitleEl   = document.getElementById("resultTitle");
  const resultTextEl    = document.getElementById("resultText");
  const resultLinkEl    = document.getElementById("resultLink");
  const resultCloseBtn  = document.getElementById("resultClose");

  const OUTER_PADDING = 120;
  const ZOOM_MIN = 0.7;
  const ZOOM_MAX = 1.3;

  let centerX = canvas.width / 2;
  let centerY = canvas.height / 2;
  // smaller radius, leaving margin for pop-out PNGs
  let radius  = canvas.width / 2 - OUTER_PADDING;


  let sliceAngle = 0;
  let currentRotation = 0;
  let isSpinning = false;

  let confettiParticles = [];
  let dragSourceIndex = null;

  function resizeConfettiCanvas() {
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
  }

  window.addEventListener("resize", resizeConfettiCanvas);
  document.addEventListener("fullscreenchange", resizeConfettiCanvas);

  // ===== Contrast-based text color =====
  const textColorCache = new Map();

  function getReadableTextColor(bgColor) {
    if (textColorCache.has(bgColor)) return textColorCache.get(bgColor);

    let probe = getReadableTextColor._probe;
    if (!probe) {
      probe = document.createElement("span");
      probe.style.display = "none";
      document.body.appendChild(probe);
      getReadableTextColor._probe = probe;
    }

    try {
      probe.style.color = bgColor;
      const cs = getComputedStyle(probe).color;
      const m = cs.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
      if (!m) throw new Error("Cannot parse color");

      const r = parseInt(m[1], 10) / 255;
      const g = parseInt(m[2], 10) / 255;
      const b = parseInt(m[3], 10) / 255;

      const RsRGB = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
      const GsRGB = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
      const BsRGB = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);

      const L = 0.2126 * RsRGB + 0.7152 * GsRGB + 0.0722 * BsRGB;
      const textColor = L > 0.6 ? "#000000" : "#ffffff";

      textColorCache.set(bgColor, textColor);
      return textColor;
    } catch {
      return "#000000";
    }
  }

  // ===== Sector management & UI =====
  function ensureSliceAngle() {
    sliceAngle = segments.length ? (2 * Math.PI) / segments.length : 0;
  }

  function addSector(initial) {
    const idx = segments.length;
    const base = initial || {};
    segments.push({
      label: base.label || `Prize ${idx + 1}`,
      url: base.url || "#",
      color: base.color || colorPalette[idx % colorPalette.length],
      imageDataUrl: base.imageDataUrl || null,
      imageObj: base.imageObj || null,
      linkEnabled: base.linkEnabled !== false,
      collapsed: !!base.collapsed
    });
    ensureSliceAngle();
    renderSectorsPanel();
    drawWheel(currentRotation);
  }

  function removeSector(index) {
    if (segments.length <= 1) return; // keep at least 1 sector
    segments.splice(index, 1);
    ensureSliceAngle();
    renderSectorsPanel();
    drawWheel(currentRotation);
  }

  function renderSectorsPanel() {
    sectorsContainer.innerHTML = "";
    segments.forEach((seg, i) => {
      const card = document.createElement("div");
      const isCollapsed = !!seg.collapsed;
      card.className = `sector-card${isCollapsed ? " collapsed" : ""}`;
      card.dataset.index = i.toString();
      card.setAttribute("draggable", "true");

      const safeLabel = seg.label.replace(/"/g, "&quot;");
      const safeUrl = seg.url.replace(/"/g, "&quot;");
      const previewStyle = seg.imageDataUrl ? `background-image:url(${seg.imageDataUrl})` : "background-image:none";

      card.innerHTML = `
        <div class="sector-header">
          <div class="sector-badge">
            <button type="button" class="drag-handle" title="Drag to reorder">☰</button>
            <span>Sector ${i + 1}</span>
            <span class="sector-color-dot" style="background:${seg.color};"></span>
          </div>
          <div class="sector-actions">
            <button type="button" class="collapse-toggle" aria-expanded="${!isCollapsed}" title="${isCollapsed ? "Expand" : "Collapse"}">
              ${isCollapsed ? "▸" : "▾"}
            </button>
            <button type="button" class="sector-delete"${segments.length <= 1 ? " disabled" : ""} title="Remove sector">
              ✕
            </button>
          </div>
        </div>

        <div class="sector-body">
          <div>
            <label>Label</label>
            <input type="text" class="sector-label" value="${safeLabel}" />
          </div>

          <div>
            <div class="sector-link-row">
              <label>Link</label>
              <label class="link-toggle">
                <input type="checkbox" class="sector-link-enabled"${seg.linkEnabled === false ? "" : " checked"} />
                Enable link
              </label>
            </div>
            <input type="url" class="sector-url" value="${safeUrl}" ${seg.linkEnabled === false ? "disabled" : ""} />
          </div>

          <div class="sector-row-inline">
            <div>
              <label>Color</label>
              <input type="color" class="sector-color" value="${seg.color}" />
            </div>
            <div class="sector-image-wrapper">
              <div class="sector-image-preview" style="${previewStyle}"></div>
              <div style="flex:1;">
                <label style="font-weight:500;">Image (PNG)</label>
                <input type="file" class="sector-image" accept="image/*">
              </div>
            </div>
          </div>
        </div>
      `;

      sectorsContainer.appendChild(card);
    });
  }

  sectorsContainer.addEventListener("input", (e) => {
    const target = e.target;
    const card = target.closest(".sector-card");
    if (!card) return;
    const index = parseInt(card.dataset.index, 10);
    const seg = segments[index];
    if (!seg) return;

    if (target.classList.contains("sector-label")) {
      seg.label = target.value || `Prize ${index + 1}`;
    } else if (target.classList.contains("sector-url")) {
      seg.url = target.value || "#";
    } else if (target.classList.contains("sector-color")) {
      seg.color = target.value || seg.color;
    }
    const dot = card.querySelector(".sector-color-dot");
    if (dot) dot.style.background = seg.color;

    drawWheel(currentRotation);
  });

  // image loading – PNG, no clipping & link toggles
  sectorsContainer.addEventListener("change", (e) => {
    const target = e.target;
    const card = target.closest(".sector-card");
    if (!card) return;
    const index = parseInt(card.dataset.index, 10);
    const seg = segments[index];
    if (!seg) return;

    if (target.classList.contains("sector-link-enabled")) {
      seg.linkEnabled = target.checked;
      const urlInput = card.querySelector(".sector-url");
      if (urlInput) urlInput.disabled = !seg.linkEnabled;
      drawWheel(currentRotation);
      return;
    }

    if (!target.classList.contains("sector-image")) return;

    const preview = card.querySelector(".sector-image-preview");

    const file = target.files[0];
    if (!file) {
      seg.imageDataUrl = null;
      seg.imageObj = null;
      if (preview) preview.style.backgroundImage = "none";
      drawWheel(currentRotation);
      return;
    }

    const reader = new FileReader();
    reader.onload = () => {
      const dataUrl = reader.result;
      const img = new Image();
      img.onload = () => {
        seg.imageDataUrl = dataUrl;
        seg.imageObj = img;
        if (preview) preview.style.backgroundImage = `url(${dataUrl})`;
        drawWheel(currentRotation);
      };
      img.src = dataUrl;
    };
    reader.readAsDataURL(file);
  });

  sectorsContainer.addEventListener("click", (e) => {
    const target = e.target;
    if (target.classList.contains("sector-delete") && !target.disabled) {
      const card = target.closest(".sector-card");
      if (!card) return;
      const index = parseInt(card.dataset.index, 10);
      removeSector(index);
    } else if (target.classList.contains("collapse-toggle")) {
      const card = target.closest(".sector-card");
      if (!card) return;
      const index = parseInt(card.dataset.index, 10);
      const seg = segments[index];
      if (!seg) return;
      seg.collapsed = !seg.collapsed;
      renderSectorsPanel();
    }
  });

  sectorsContainer.addEventListener("dragstart", (e) => {
    const card = e.target.closest(".sector-card");
    const handle = e.target.closest(".drag-handle");
    if (!card || !handle || !card.contains(handle)) {
      e.preventDefault();
      return;
    }
    dragSourceIndex = parseInt(card.dataset.index, 10);
    card.classList.add("dragging");
    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData("text/plain", dragSourceIndex.toString());
  });

  sectorsContainer.addEventListener("dragend", (e) => {
    const card = e.target.closest(".sector-card");
    if (card) card.classList.remove("dragging");
    dragSourceIndex = null;
  });

  sectorsContainer.addEventListener("dragover", (e) => {
    const card = e.target.closest(".sector-card");
    if (!card || dragSourceIndex === null) return;
    e.preventDefault();
    card.classList.add("drag-over");
  });

  sectorsContainer.addEventListener("dragleave", (e) => {
    const card = e.target.closest(".sector-card");
    if (card) card.classList.remove("drag-over");
  });

  sectorsContainer.addEventListener("drop", (e) => {
    const card = e.target.closest(".sector-card");
    if (!card || dragSourceIndex === null) return;
    e.preventDefault();
    card.classList.remove("drag-over");
    const destIndex = parseInt(card.dataset.index, 10);
    if (Number.isNaN(destIndex) || destIndex === dragSourceIndex) return;

    const [moved] = segments.splice(dragSourceIndex, 1);
    const insertionIndex = destIndex > dragSourceIndex ? destIndex - 1 : destIndex;
    segments.splice(insertionIndex, 0, moved);
    dragSourceIndex = null;

    ensureSliceAngle();
    renderSectorsPanel();
    drawWheel(currentRotation);
  });

  addSectorBtn.addEventListener("click", () => {
    addSector();
  });

  showImagesToggle.addEventListener("change", () => {
    showImages = showImagesToggle.checked;
    drawWheel(currentRotation);
  });

  function setWheelZoom(value) {
    const clamped = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, value));
    wheelZoom = clamped;
    wheelWrapper.style.setProperty("--wheel-zoom", clamped.toString());
    if (zoomSlider) zoomSlider.value = clamped.toFixed(2);
    if (zoomValue) zoomValue.textContent = `${Math.round(clamped * 100)}%`;
  }

  if (zoomSlider) {
    zoomSlider.addEventListener("input", () => {
      const val = parseFloat(zoomSlider.value);
      if (!Number.isNaN(val)) setWheelZoom(val);
    });
  }

  zoomButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const delta = parseFloat(btn.dataset.delta || "0");
      setWheelZoom(wheelZoom + delta);
    });
  });

  // ===== Modal =====
  function hideResultModal() {
    resultModal.classList.add("hidden");
  }

  function showResultModal() {
    const content = resultModal.querySelector(".result-modal__content");
    content.style.animation = "none";
    void content.offsetWidth;
    content.style.animation = "";
    resultModal.classList.remove("hidden");
  }

  resultCloseBtn.addEventListener("click", hideResultModal);
  resultBackdrop.addEventListener("click", hideResultModal);

  // ===== Drawing wheel =====
  function drawWheel(rotation) {
    if (!segments.length) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      return;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(centerX, centerY);

    const centerRadius = radius * 0.18; // a bit smaller, so text rarely collides
    const textRadius = radius - 70;     // text placed more inward

    segments.forEach((segment, index) => {
      const startAngle = rotation + index * sliceAngle;
      const endAngle   = startAngle + sliceAngle;
      const midAngle   = startAngle + sliceAngle / 2;

      // Slice
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, radius, startAngle, endAngle);
      ctx.closePath();
      ctx.fillStyle = segment.color;
      ctx.fill();

      // Text, auto-shrink if too long (so it doesn't hit the center logo)
      ctx.save();
      ctx.rotate(midAngle);
      ctx.textAlign = "right";
      const readable = getReadableTextColor(segment.color);

      let baseFontSize = 26;
      ctx.font = `600 ${baseFontSize}px 'Montserrat', system-ui`;
      let textWidth = ctx.measureText(segment.label).width;
      const maxWidth = textRadius - (centerRadius + 30); // safe distance from center

      if (maxWidth > 0 && textWidth > maxWidth) {
        const scale = maxWidth / textWidth;
        let newSize = Math.floor(baseFontSize * scale);
        newSize = Math.max(14, newSize); // don't go too tiny
        ctx.font = `600 ${newSize}px 'Montserrat', system-ui`;
      }

      ctx.fillStyle = readable;
      ctx.fillText(segment.label, textRadius, 10);
      ctx.restore();

      // Prize image PNG – no border, no clipping, slightly popping out
      if (showImages && segment.imageObj) {
        // Scale with radius, but clamp to avoid huge sprites
        const size = Math.min(radius * 0.22, 160);       // square size
        const imgRadius = radius + size * 0.15;          // center slightly outside wheel edge

        const x = Math.cos(midAngle) * imgRadius;
        const y = Math.sin(midAngle) * imgRadius;

        ctx.save();
        ctx.translate(x, y);
        ctx.shadowColor = "rgba(0,0,0,0.35)";
        ctx.shadowBlur = 10;
        ctx.shadowOffsetY = 4;

        ctx.drawImage(segment.imageObj, -size/2, -size/2, size, size);

        ctx.restore();
      }
    });

    // Center circle + logo
    ctx.beginPath();
    ctx.arc(0, 0, centerRadius, 0, 2 * Math.PI);
    ctx.fillStyle = "#ffffff";
    ctx.fill();

    if (logoImg) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(0, 0, centerRadius - 6, 0, 2 * Math.PI);
      ctx.closePath();
      ctx.clip();

      const size = (centerRadius - 6) * 2;
      ctx.drawImage(logoImg, -size/2, -size/2, size, size);
      ctx.restore();
    }

    ctx.restore();
  }

  // ===== Spin logic =====
  function spin() {
    if (isSpinning || !segments.length) return;

    isSpinning = true;
    hideResultModal();
    wheelWrapper.classList.add("spin-anim");

    const spins = 4 + Math.random() * 3;
    const extraRotation = Math.random() * 2 * Math.PI;
    const startRotation = currentRotation;
    const targetRotation = startRotation + spins * 2 * Math.PI + extraRotation;
    const duration = 4000;
    const startTime = performance.now();

    function animate(now) {
      const elapsed = now - startTime;
      const t = Math.min(elapsed / duration, 1);
      const eased = 1 - Math.pow(1 - t, 3);

      currentRotation = startRotation + (targetRotation - startRotation) * eased;
      drawWheel(currentRotation);

      if (t < 1) {
        requestAnimationFrame(animate);
      } else {
        isSpinning = false;
        wheelWrapper.classList.remove("spin-anim");
        showWinner();
      }
    }
    requestAnimationFrame(animate);
  }

  function showWinner() {
    if (!segments.length) return;

    let rot = currentRotation % (2 * Math.PI);
    if (rot < 0) rot += 2 * Math.PI;

    const pointerAngleInWheel = (2 * Math.PI - rot) % (2 * Math.PI);
    let index = Math.floor(pointerAngleInWheel / sliceAngle);
    if (index === segments.length) index = 0;

    const segment = segments[index];

    resultTitleEl.textContent = "You got:";
    resultTextEl.textContent = segment.label;
    const linkAllowed = segment.linkEnabled !== false && segment.url && segment.url !== "#";
    resultLinkEl.href = linkAllowed ? segment.url : "#";
    resultLinkEl.classList.toggle("hidden", !linkAllowed);

    showResultModal();
    startConfetti();
  }

  wheelWrapper.addEventListener("click", spin);

  // ===== Confetti =====
  function startConfetti() {
    resizeConfettiCanvas();
    const width = confettiCanvas.width;
    const height = confettiCanvas.height;

    const colors = ["#ff4b4b", "#ffd166", "#06d6a0", "#118ab2", "#ef476f", "#ffffff"];

    const count = 200;
    confettiParticles = [];
    for (let i = 0; i < count; i++) {
      confettiParticles.push({
        x: Math.random() * width,
        y: Math.random() * -height,
        r: 4 + Math.random() * 4,
        color: colors[Math.floor(Math.random() * colors.length)],
        vx: (Math.random() - 0.5) * 3,
        vy: 3 + Math.random() * 3,
        rotation: Math.random() * 2 * Math.PI,
        vr: (Math.random() - 0.5) * 0.25
      });
    }

    const duration = 2000;
    const start = performance.now();

    function frame(now) {
      const elapsed = now - start;
      const t = Math.min(elapsed / duration, 1);
      const alpha = 1 - t;

      confettiCtx.clearRect(0, 0, width, height);
      confettiCtx.save();
      confettiCtx.globalAlpha = alpha;

      confettiParticles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.05;
        p.rotation += p.vr;
        if (p.y - p.r > height + 20) return;

        confettiCtx.save();
        confettiCtx.translate(p.x, p.y);
        confettiCtx.rotate(p.rotation);
        confettiCtx.fillStyle = p.color;
        confettiCtx.fillRect(-p.r, -p.r, p.r * 2, p.r * 2);
        confettiCtx.restore();
      });

      confettiCtx.restore();

      if (t < 1) {
        requestAnimationFrame(frame);
      } else {
        confettiCtx.clearRect(0, 0, width, height);
      }
    }
    requestAnimationFrame(frame);
  }

  // ===== Logo & background uploads =====
  logoInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) {
      logoImg = null;
      logoDataUrl = null;
      drawWheel(currentRotation);
      return;
    }
    const reader = new FileReader();
    reader.onload = () => {
      logoDataUrl = reader.result;
      const img = new Image();
      img.onload = () => {
        logoImg = img;
        drawWheel(currentRotation);
      };
      img.src = logoDataUrl;
    };
    reader.readAsDataURL(file);
  });

  bgInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) {
      bgDataUrl = null;
      appEl.style.backgroundImage = "";
      return;
    }
    const reader = new FileReader();
    reader.onload = () => {
      bgDataUrl = reader.result;
      appEl.style.backgroundImage = `url(${bgDataUrl})`;
    };
    reader.readAsDataURL(file);
  });

  // ===== Export / import config =====
  exportBtn.addEventListener("click", () => {
    const config = {
      segments: segments.map(s => ({
        label: s.label,
        url: s.url,
        color: s.color,
        imageDataUrl: s.imageDataUrl || null,
        linkEnabled: s.linkEnabled !== false
      })),
      showImages,
      logoDataUrl: logoDataUrl || null,
      backgroundDataUrl: bgDataUrl || null
    };

    const blob = new Blob([JSON.stringify(config, null, 2)], {
      type: "application/json"
    });

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    a.href = url;
    a.download = `wheel-config-${timestamp}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  });

  importBtn.addEventListener("click", () => {
    importInput.value = "";
    importInput.click();
  });

  importInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = () => {
      try {
        const data = JSON.parse(reader.result);

        if (typeof data !== "object" || data === null) {
          alert("Invalid config file.");
          return;
        }

        if (Array.isArray(data.segments) && data.segments.length) {
          segments = data.segments.map((s, i) => ({
            label: s.label || `Prize ${i + 1}`,
            url: s.url || "#",
            color: s.color || colorPalette[i % colorPalette.length],
            imageDataUrl: s.imageDataUrl || null,
            imageObj: null,
            linkEnabled: s.linkEnabled !== false,
            collapsed: false
          }));
        } else if (typeof data.entries === "string" && data.entries.trim().length) {
          const lines = data.entries.split("\n").map(l => l.trim()).filter(Boolean);
          segments = lines.map((line, i) => {
            const parts = line.split("|").map(p => p.trim());
            return {
              label: parts[0] || `Prize ${i + 1}`,
              url: parts[1] || "#",
              color: parts[2] || colorPalette[i % colorPalette.length],
              imageDataUrl: null,
              imageObj: null,
              linkEnabled: true,
              collapsed: false
            };
          });
        }

        if (!segments.length) {
          alert("Config has no segments.");
          return;
        }

        showImages = data.showImages !== false;
        showImagesToggle.checked = showImages;

        ensureSliceAngle();
        renderSectorsPanel();

        if (typeof data.backgroundDataUrl === "string" && data.backgroundDataUrl.startsWith("data:")) {
          bgDataUrl = data.backgroundDataUrl;
          appEl.style.backgroundImage = `url(${bgDataUrl})`;
        } else {
          bgDataUrl = null;
          appEl.style.backgroundImage = "";
        }

        if (typeof data.logoDataUrl === "string" && data.logoDataUrl.startsWith("data:")) {
          logoDataUrl = data.logoDataUrl;
          const img = new Image();
          img.onload = () => {
            logoImg = img;
            drawWheel(currentRotation);
          };
          img.src = logoDataUrl;
        } else {
          logoDataUrl = null;
          logoImg = null;
          drawWheel(currentRotation);
        }

        segments.forEach((s) => {
          if (s.imageDataUrl) {
            const img = new Image();
            img.onload = () => {
              s.imageObj = img;
              drawWheel(currentRotation);
            };
            img.src = s.imageDataUrl;
          }
        });

        drawWheel(currentRotation);
      } catch (err) {
        console.error(err);
        alert("Could not read config file.");
      }
    };
    reader.readAsText(file);
  });

  // ===== Fullscreen =====
  fullscreenBtn.addEventListener("click", () => {
    if (!document.fullscreenElement) {
      settingsPanel.classList.add("hidden");
      if (appEl.requestFullscreen) appEl.requestFullscreen();
    } else {
      if (document.exitFullscreen) document.exitFullscreen();
    }
  });

  document.addEventListener("fullscreenchange", () => {
    if (!document.fullscreenElement) {
      settingsPanel.classList.remove("hidden");
      fullscreenBtn.textContent = "Fullscreen";
    } else {
      fullscreenBtn.textContent = "Exit fullscreen";
    }
  });

  // ===== Init =====
  function ensureSliceAngle() {
    sliceAngle = segments.length ? (2 * Math.PI) / segments.length : 0;
  }

  async function init() {
    segments = defaultSegmentsData.map((s, i) => ({
      label: s.label,
      url: s.url,
      color: s.color || colorPalette[i % colorPalette.length],
      imageDataUrl: null,
      imageObj: null,
      linkEnabled: true,
      collapsed: false
    }));
    ensureSliceAngle();
    renderSectorsPanel();
    resizeConfettiCanvas();
    setWheelZoom(1);

    try {
      if (document.fonts && document.fonts.load) {
        await document.fonts.load(FONT_SPEC);
      }
    } catch {}

    drawWheel(currentRotation);
  }

  init();
</script>
</body>
</html>
