<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Prize Wheel</title>

  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;600;700&display=swap" rel="stylesheet">

  <style>
    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      height: 100%;
      font-family: "Montserrat", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f9;
    }

    body {
      display: flex;
      align-items: stretch;
      justify-content: center;
    }

    .app {
      display: flex;
      flex: 1;
      max-width: 1400px;
      padding: 16px;
      gap: 16px;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      position: relative;
      z-index: 1;
    }

    .wheel-area {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .wheel-wrapper {
      --wheel-zoom: 1;
      position: relative;
      width: min(80vmin, 700px);
      height: min(80vmin, 700px);
      cursor: pointer;
      border-radius: 50%;
      box-shadow: 0 18px 45px rgba(0,0,0,0.22);
      transition: transform 0.25s ease-out, box-shadow 0.25s ease-out;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0), transparent 60%);
      transform: scale(var(--wheel-zoom));
      transform-origin: center center;
      overflow: visible;
    }

    .wheel-wrapper.spin-anim {
      transform: scale(calc(var(--wheel-zoom) * 1.03));
      box-shadow: 0 24px 60px rgba(0,0,0,0.30);
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #wheelCanvas {
      position: relative;
      z-index: 1;
    }

    /* FULLSCREEN CONFETTI OVERLAY */
    #confettiCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 900;
    }

    .pointer {
      position: absolute;
      top: 50%;
      right: -6px; /* close to wheel */
      width: 0;
      height: 0;
      border-top: 18px solid transparent;
      border-bottom: 18px solid transparent;
      border-right: 28px solid #ffffff; /* arrow points left */
      border-left: 0;
      z-index: 3;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,0.45));
    }

    .panel {
      width: 380px;
      max-width: 40%;
      background: rgba(255,255,255,0.97);
      border-radius: 16px;
      padding: 16px 18px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.08);
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 2;
      backdrop-filter: blur(6px);
      max-height: 100vh;
      overflow: auto;
    }

    .panel h2 {
      margin: 0 0 4px;
      font-size: 1.1rem;
    }

    .panel small {
      font-size: 0.75rem;
      color: #555;
    }

    label {
      font-size: 0.8rem;
      font-weight: 600;
      margin-bottom: 4px;
      display: block;
    }

    input[type="text"],
    input[type="url"] {
      width: 100%;
      font-size: 0.8rem;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #ccc;
      font-family: inherit;
    }

    input[type="color"] {
      width: 60px;
      height: 28px;
      padding: 0;
      border-radius: 999px;
      border: 1px solid #ccc;
      background: transparent;
      cursor: pointer;
    }

    input[type="file"] {
      width: 100%;
      font-size: 0.8rem;
    }

    .panel button {
      padding: 8px 14px;
      font-size: 0.85rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: #111;
      color: #fff;
      align-self: flex-start;
      letter-spacing: 0.02em;
    }

    .panel button:hover {
      opacity: 0.9;
    }

    .panel-row {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .panel .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 4px;
    }

    .toggle-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .toggle-row input {
      width: auto;
    }

    .sectors-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 4px;
    }

    .sector-card {
      border-radius: 10px;
      padding: 8px 10px;
      border: 1px solid #e0e0e0;
      background: #fafafa;
      display: flex;
      flex-direction: column;
      gap: 6px;
      position: relative;
    }

    .sector-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.8rem;
      font-weight: 600;
    }

    .sector-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.75rem;
    }

    .sector-actions {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .sector-color-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,0.2);
      background: #ccc;
    }

    .collapse-toggle,
    .drag-handle {
      background: transparent;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 0.8rem;
      cursor: pointer;
      color: #444;
    }

    .drag-handle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      gap: 4px;
    }

    .sector-card.collapsed .sector-body {
      display: none;
    }

    .sector-body {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .sector-card.drag-over {
      border-color: #111;
      box-shadow: inset 0 0 0 1px #111;
    }

    .sector-delete {
      background: transparent;
      color: #777;
      font-size: 0.9rem;
      border: none;
      cursor: pointer;
      padding: 2px 6px;
    }

    .sector-delete[disabled] {
      opacity: 0.4;
      cursor: default;
    }

    .sector-delete:hover:not([disabled]) {
      color: #000;
    }

    .sector-row-inline {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .sector-row-inline > div {
      flex: 1;
    }

    .sector-image-preview {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      border: 1px solid #ddd;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      flex-shrink: 0;
    }

    .sector-image-wrapper {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sector-link-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .link-toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 500;
      font-size: 0.75rem;
    }

    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .zoom-controls input[type="range"] {
      flex: 1;
      min-width: 140px;
    }

    .zoom-value {
      font-size: 0.8rem;
      font-weight: 600;
    }

    .hidden {
      display: none !important;
    }

    /* Result modal */
    .result-modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .result-modal__backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.45);
    }

    .result-modal__content {
      position: relative;
      background: #ffffff;
      border-radius: 16px;
      padding: 20px 24px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.25);
      max-width: 320px;
      text-align: center;
      z-index: 1;
      transform: translateY(10px) scale(0.96);
      opacity: 0;
      animation: popup-in 0.25s ease-out forwards;
    }

    .result-modal__content h3 {
      margin: 0 0 8px;
      font-size: 1.1rem;
    }

    .result-modal__content p {
      margin: 0 0 12px;
      font-size: 0.95rem;
    }

    .result-modal__content a {
      display: inline-block;
      margin-bottom: 12px;
      font-size: 0.9rem;
      text-decoration: underline;
      color: #111;
      word-break: break-all;
    }

    .result-modal__content button {
      padding: 8px 18px;
      border-radius: 999px;
      border: none;
      background: #111;
      color: #fff;
      cursor: pointer;
      font-size: 0.9rem;
      letter-spacing: 0.02em;
    }

    .result-modal__content button:hover {
      opacity: 0.9;
    }

    @keyframes popup-in {
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @media (max-width: 900px) {
      .app {
        flex-direction: column;
      }
      .panel {
        width: 100%;
        max-width: 100%;
        order: -1;
      }

    }
  </style>
</head>
<body>
<div class="app">
  <div class="wheel-area" id="wheelArea">
    <div class="wheel-wrapper" id="wheelWrapper">
      <canvas id="wheelCanvas" width="1200" height="1200"></canvas>
      <div class="pointer"></div>
    </div>
  </div>

  <div class="panel" id="settingsPanel">
    <div class="panel-row">
      <h2>Prize wheel</h2>
      <small>Click the wheel to spin. Changes save automatically.</small>
    </div>

    <div class="panel-row">
      <label class="toggle-row">
        <input type="checkbox" id="showImagesToggle" checked>
        Show prize images on sectors
      </label>
    </div>

    <div class="panel-row">
      <label for="zoomSlider">Wheel zoom</label>
      <div class="zoom-controls">
        <button type="button" class="zoom-btn" data-delta="-0.05">−</button>
        <input type="range" id="zoomSlider" min="0.7" max="1.3" step="0.05" value="1">
        <button type="button" class="zoom-btn" data-delta="0.05">+</button>
        <span class="zoom-value" id="zoomValue">100%</span>
      </div>
    </div>

    <div class="panel-row">
      <div class="sectors-container" id="sectorsContainer"></div>
      <div class="btn-row">
        <button id="addSectorBtn">+ Add sector</button>
        <button id="resetBtn" style="background:#ff4b4b;">Reset to Default</button>
      </div>
    </div>

    <div class="panel-row">
      <label for="logoInput">Center logo (optional)</label>
      <input type="file" id="logoInput" accept="image/*">
    </div>

    <div class="panel-row">
      <label for="bgInput">Background image (optional)</label>
      <input type="file" id="bgInput" accept="image/*">
    </div>

    <div class="panel-row">
      <label>Config</label>
      <div class="btn-row">
        <button id="exportBtn">Export config</button>
        <button id="importBtn">Import config</button>
      </div>
      <input type="file" id="importInput" accept="application/json" style="display:none">
    </div>

    <div class="panel-row">
      <button id="fullscreenBtn">Fullscreen</button>
    </div>
  </div>

  <canvas id="confettiCanvas"></canvas>

  <div id="resultModal" class="result-modal hidden">
    <div id="resultBackdrop" class="result-modal__backdrop"></div>
    <div class="result-modal__content">
      <h3 id="resultTitle">You got:</h3>
      <p id="resultText"></p>
      <a id="resultLink" href="#" target="_blank" rel="noopener noreferrer">Open prize page</a><br>
      <button id="resultClose">OK</button>
    </div>
  </div>
</div>

<script>
  const FONT_SPEC = "600 26px 'Montserrat', system-ui";
  const LOCAL_STORAGE_KEY = "prize_wheel_config";

  const defaultSegmentsData = [
    { label: "Blum hardware pack", url: "https://example.com/blum",  color: "#ff4b4b" },
    { label: "Hinge upgrade",      url: "https://example.com/hinges",color: "#ffb347" },
    { label: "Lighting pack",      url: "https://example.com/lighting", color: "#ffe66d" },
    { label: "Worktop voucher",    url: "https://example.com/worktop", color: "#7bd389" },
    { label: "Kitchen consult",    url: "https://example.com/consult", color: "#4f98ca" },
    { label: "Accessory set",      url: "https://example.com/accessories", color: "#b084f4" },
    { label: "Mystery prize",      url: "https://example.com/mystery", color: "#ff6fb5" }
  ];

  const colorPalette = [
    "#ff4b4b", "#ffb347", "#ffe66d", "#7bd389",
    "#4f98ca", "#b084f4", "#ff6fb5", "#ffa3a3"
  ];

  // state
  let segments = []; 
  let showImages = true;
  let logoImg = null;
  let logoDataUrl = null;
  let bgDataUrl = null;
  let wheelZoom = 1;

  const canvas   = document.getElementById("wheelCanvas");
  const ctx      = canvas.getContext("2d");

  const confettiCanvas = document.getElementById("confettiCanvas");
  const confettiCtx    = confettiCanvas.getContext("2d");

  const appEl          = document.querySelector(".app");
  const wheelWrapper   = document.getElementById("wheelWrapper");
  const settingsPanel  = document.getElementById("settingsPanel");

  const sectorsContainer = document.getElementById("sectorsContainer");
  const addSectorBtn     = document.getElementById("addSectorBtn");
  const resetBtn         = document.getElementById("resetBtn");
  const showImagesToggle = document.getElementById("showImagesToggle");
  const logoInput        = document.getElementById("logoInput");
  const bgInput          = document.getElementById("bgInput");
  const exportBtn        = document.getElementById("exportBtn");
  const importBtn        = document.getElementById("importBtn");
  const importInput      = document.getElementById("importInput");
  const fullscreenBtn    = document.getElementById("fullscreenBtn");
  const zoomSlider       = document.getElementById("zoomSlider");
  const zoomValue        = document.getElementById("zoomValue");
  const zoomButtons      = document.querySelectorAll(".zoom-btn");

  const resultModal     = document.getElementById("resultModal");
  const resultBackdrop  = document.getElementById("resultBackdrop");
  const resultTitleEl   = document.getElementById("resultTitle");
  const resultTextEl    = document.getElementById("resultText");
  const resultLinkEl    = document.getElementById("resultLink");
  const resultCloseBtn  = document.getElementById("resultClose");

  const OUTER_PADDING = 80;
  const ZOOM_MIN = 0.7;
  const ZOOM_MAX = 1.3;

  let centerX = canvas.width / 2;
  let centerY = canvas.height / 2;
  let radius  = canvas.width / 2 - OUTER_PADDING;

  let sliceAngle = 0;
  let currentRotation = 0;
  let isSpinning = false;

  let confettiParticles = [];
  let dragSourceIndex = null;
  let dragHandleIndex = null;

  function resizeConfettiCanvas() {
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
  }

  window.addEventListener("resize", resizeConfettiCanvas);
  document.addEventListener("fullscreenchange", resizeConfettiCanvas);

  // ===== Utils =====

  // Helper to resize/compress images so they fit in LocalStorage
  function processImage(file, maxWidth, quality = 0.7) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          let w = img.width;
          let h = img.height;
          // Scale down if too big
          if (w > maxWidth) {
            h = (h * maxWidth) / w;
            w = maxWidth;
          }
          canvas.width = w;
          canvas.height = h;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, w, h);
          // Compress to JPEG/PNG
          const type = file.type === 'image/png' ? 'image/png' : 'image/jpeg';
          resolve(canvas.toDataURL(type, quality));
        };
        img.onerror = reject;
        img.src = e.target.result;
      };
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  // ===== Contrast-based text color =====
  const textColorCache = new Map();

  function getReadableTextColor(bgColor) {
    if (textColorCache.has(bgColor)) return textColorCache.get(bgColor);

    let probe = getReadableTextColor._probe;
    if (!probe) {
      probe = document.createElement("span");
      probe.style.display = "none";
      document.body.appendChild(probe);
      getReadableTextColor._probe = probe;
    }

    try {
      probe.style.color = bgColor;
      const cs = getComputedStyle(probe).color;
      const m = cs.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
      if (!m) throw new Error("Cannot parse color");

      const r = parseInt(m[1], 10) / 255;
      const g = parseInt(m[2], 10) / 255;
      const b = parseInt(m[3], 10) / 255;

      const RsRGB = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
      const GsRGB = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
      const BsRGB = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);

      const L = 0.2126 * RsRGB + 0.7152 * GsRGB + 0.0722 * BsRGB;
      const textColor = L > 0.6 ? "#000000" : "#ffffff";

      textColorCache.set(bgColor, textColor);
      return textColor;
    } catch {
      return "#000000";
    }
  }

  // ===== State Management (Persistence) =====
  function saveLocalState() {
    const state = {
      segments: segments.map(s => ({
        label: s.label,
        url: s.url,
        color: s.color,
        imageDataUrl: s.imageDataUrl || null,
        linkEnabled: s.linkEnabled,
        collapsed: s.collapsed
      })),
      showImages,
      wheelZoom,
      logoDataUrl,
      bgDataUrl,
      // alias for loader + exported configs
      backgroundDataUrl: bgDataUrl || null
    };

    try {
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state));
    } catch (e) {
      console.warn(
        "Storage full. Could not save state. Data size:",
        JSON.stringify(state).length / 1024 / 1024,
        "MB",
        e
      );
      // alert removed on purpose – too annoying if it triggers often
    }
  }

  // ===== Sector management & UI =====
  function ensureSliceAngle() {
    sliceAngle = segments.length ? (2 * Math.PI) / segments.length : 0;
  }

  function addSector(initial) {
    const idx = segments.length;
    const base = initial || {};
    segments.push({
      label: base.label || `Prize ${idx + 1}`,
      url: base.url || "#",
      color: base.color || colorPalette[idx % colorPalette.length],
      imageDataUrl: base.imageDataUrl || null,
      imageObj: base.imageObj || null,
      linkEnabled: base.linkEnabled !== false,
      collapsed: !!base.collapsed
    });
    ensureSliceAngle();
    renderSectorsPanel();
    drawWheel(currentRotation);
    saveLocalState();
  }

  function removeSector(index) {
    if (segments.length <= 1) return; // keep at least 1 sector
    segments.splice(index, 1);
    ensureSliceAngle();
    renderSectorsPanel();
    drawWheel(currentRotation);
    saveLocalState();
  }

  function renderSectorsPanel() {
    sectorsContainer.innerHTML = "";
    segments.forEach((seg, i) => {
      const card = document.createElement("div");
      const isCollapsed = !!seg.collapsed;
      card.className = `sector-card${isCollapsed ? " collapsed" : ""}`;
      card.dataset.index = i.toString();
      card.setAttribute("draggable", "true");

      const safeLabel = seg.label.replace(/"/g, "&quot;");
      const safeUrl = seg.url.replace(/"/g, "&quot;");
      const previewStyle = seg.imageDataUrl ? `background-image:url(${seg.imageDataUrl})` : "background-image:none";

      card.innerHTML = `
        <div class="sector-header">
          <div class="sector-badge">
            <button type="button" class="drag-handle" title="Drag to reorder">☰</button>
            <span>Sector ${i + 1}</span>
            <span class="sector-color-dot" style="background:${seg.color};"></span>
          </div>
          <div class="sector-actions">
            <button type="button" class="collapse-toggle" aria-expanded="${!isCollapsed}" title="${isCollapsed ? "Expand" : "Collapse"}">
              ${isCollapsed ? "▸" : "▾"}
            </button>
            <button type="button" class="sector-delete"${segments.length <= 1 ? " disabled" : ""} title="Remove sector">
              ✕
            </button>
          </div>
        </div>

        <div class="sector-body">
          <div>
            <label>Label</label>
            <input type="text" class="sector-label" value="${safeLabel}" />
          </div>

          <div>
            <div class="sector-link-row">
              <label>Link</label>
              <label class="link-toggle">
                <input type="checkbox" class="sector-link-enabled"${seg.linkEnabled === false ? "" : " checked"} />
                Enable link
              </label>
            </div>
            <input type="url" class="sector-url" value="${safeUrl}" ${seg.linkEnabled === false ? "disabled" : ""} />
          </div>

          <div class="sector-row-inline">
            <div>
              <label>Color</label>
              <input type="color" class="sector-color" value="${seg.color}" />
            </div>
            <div class="sector-image-wrapper">
              <div class="sector-image-preview" style="${previewStyle}"></div>
              <div style="flex:1;">
                <label style="font-weight:500;">Image (PNG)</label>
                <input type="file" class="sector-image" accept="image/*">
              </div>
            </div>
          </div>
        </div>
      `;

      sectorsContainer.appendChild(card);
    });
  }

  sectorsContainer.addEventListener("input", (e) => {
    const target = e.target;
    const card = target.closest(".sector-card");
    if (!card) return;
    const index = parseInt(card.dataset.index, 10);
    const seg = segments[index];
    if (!seg) return;

    if (target.classList.contains("sector-label")) {
      seg.label = target.value || `Prize ${index + 1}`;
    } else if (target.classList.contains("sector-url")) {
      seg.url = target.value || "#";
    } else if (target.classList.contains("sector-color")) {
      seg.color = target.value || seg.color;
    }
    const dot = card.querySelector(".sector-color-dot");
    if (dot) dot.style.background = seg.color;

    drawWheel(currentRotation);
    saveLocalState();
  });

  // image loading
  sectorsContainer.addEventListener("change", (e) => {
    const target = e.target;
    const card = target.closest(".sector-card");
    if (!card) return;
    const index = parseInt(card.dataset.index, 10);
    const seg = segments[index];
    if (!seg) return;

    if (target.classList.contains("sector-link-enabled")) {
      seg.linkEnabled = target.checked;
      const urlInput = card.querySelector(".sector-url");
      if (urlInput) urlInput.disabled = !seg.linkEnabled;
      drawWheel(currentRotation);
      saveLocalState();
    }
  });

  // Drag/Drop logic
  sectorsContainer.addEventListener("mousedown", (e) => {
    const handle = e.target.closest(".drag-handle");
    const card = handle?.closest(".sector-card");
    if (!card) return;
    dragHandleIndex = parseInt(card.dataset.index, 10);
  });

  sectorsContainer.addEventListener("dragstart", (e) => {
    const card = e.target.closest(".sector-card");
    if (!card) return;
    const index = parseInt(card.dataset.index, 10);
    if (dragHandleIndex !== index) {
      e.preventDefault();
      return;
    }
    dragSourceIndex = index;
    card.classList.add("dragging");
    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData("text/plain", dragSourceIndex.toString());
  });

  sectorsContainer.addEventListener("dragend", (e) => {
    const card = e.target.closest(".sector-card");
    if (card) card.classList.remove("dragging");
    dragSourceIndex = null;
    dragHandleIndex = null;
  });

  sectorsContainer.addEventListener("dragover", (e) => {
    const card = e.target.closest(".sector-card");
    if (!card || dragSourceIndex === null) return;
    e.preventDefault();
    card.classList.add("drag-over");
  });

  sectorsContainer.addEventListener("dragleave", (e) => {
    const card = e.target.closest(".sector-card");
    if (card) card.classList.remove("drag-over");
  });

  sectorsContainer.addEventListener("drop", (e) => {
    const card = e.target.closest(".sector-card");
    if (!card || dragSourceIndex === null) return;
    e.preventDefault();
    card.classList.remove("drag-over");
    const destIndex = parseInt(card.dataset.index, 10);
    if (Number.isNaN(destIndex) || destIndex === dragSourceIndex) return;

    const [moved] = segments.splice(dragSourceIndex, 1);
    const insertionIndex = destIndex > dragSourceIndex ? destIndex - 1 : destIndex;
    segments.splice(insertionIndex, 0, moved);
    dragSourceIndex = null;

    ensureSliceAngle();
    renderSectorsPanel();
    drawWheel(currentRotation);
    saveLocalState();
  });

  addSectorBtn.addEventListener("click", () => {
    addSector();
  });

  resetBtn.addEventListener("click", () => {
    if(confirm("Are you sure you want to reset the wheel to default? This will clear all your changes.")) {
      localStorage.removeItem(LOCAL_STORAGE_KEY);
      location.reload();
    }
  });

  showImagesToggle.addEventListener("change", () => {
    showImages = showImagesToggle.checked;
    drawWheel(currentRotation);
    saveLocalState();
  });

  function setWheelZoom(value) {
    const clamped = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, value));
    wheelZoom = clamped;
    wheelWrapper.style.setProperty("--wheel-zoom", clamped.toString());
    if (zoomSlider) zoomSlider.value = clamped.toFixed(2);
    if (zoomValue) zoomValue.textContent = `${Math.round(clamped * 100)}%`;
    saveLocalState();
  }

  if (zoomSlider) {
    zoomSlider.addEventListener("input", () => {
      const val = parseFloat(zoomSlider.value);
      if (!Number.isNaN(val)) setWheelZoom(val);
    });
  }

  zoomButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const delta = parseFloat(btn.dataset.delta || "0");
      setWheelZoom(wheelZoom + delta);
    });
  });

  // ===== Fullscreen =====
  function toggleFullscreen() {
    const elem = document.documentElement;
    if (!document.fullscreenElement) {
      if (elem.requestFullscreen) elem.requestFullscreen();
      else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
      else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
    } else {
      if (document.exitFullscreen) document.exitFullscreen();
      else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
      else if (document.msExitFullscreen) document.msExitFullscreen();
    }
  }

  if (fullscreenBtn) {
    fullscreenBtn.addEventListener("click", toggleFullscreen);
  }

  document.addEventListener("fullscreenchange", () => {
    if (!fullscreenBtn) return;
    if (document.fullscreenElement) {
      fullscreenBtn.textContent = "Exit fullscreen";
      settingsPanel.style.display = "none";
    } else {
      fullscreenBtn.textContent = "Fullscreen";
      settingsPanel.style.display = "flex";
    }
  });

  // ===== Modal =====
  function hideResultModal() {
    resultModal.classList.add("hidden");
  }

  function showResultModal() {
    const content = resultModal.querySelector(".result-modal__content");
    content.style.animation = "none";
    void content.offsetWidth;
    content.style.animation = "";
    resultModal.classList.remove("hidden");
  }

  resultCloseBtn.addEventListener("click", hideResultModal);
  resultBackdrop.addEventListener("click", hideResultModal);

  // ===== Drawing wheel =====
  function drawWheel(rotation) {
    if (!segments.length) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      return;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(centerX, centerY);

    const centerRadius = radius * 0.18; 
    const textRadius = radius - 70;     

    segments.forEach((segment, index) => {
      const startAngle = rotation + index * sliceAngle;
      const endAngle   = startAngle + sliceAngle;
      const midAngle   = startAngle + sliceAngle / 2;

      // Slice
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, radius, startAngle, endAngle);
      ctx.closePath();
      ctx.fillStyle = segment.color;
      ctx.fill();

      // Text
      ctx.save();
      ctx.rotate(midAngle);
      ctx.textAlign = "right";
      const readable = getReadableTextColor(segment.color);

      let baseFontSize = 26;
      ctx.font = `600 ${baseFontSize}px 'Montserrat', system-ui`;
      let textWidth = ctx.measureText(segment.label).width;
      const maxWidth = textRadius - (centerRadius + 30); 

      if (maxWidth > 0 && textWidth > maxWidth) {
        const scale = maxWidth / textWidth;
        let newSize = Math.floor(baseFontSize * scale);
        newSize = Math.max(14, newSize); 
        ctx.font = `600 ${newSize}px 'Montserrat', system-ui`;
      }

      ctx.fillStyle = readable;
      ctx.fillText(segment.label, textRadius, 10);
      ctx.restore();

      // Prize image
      if (showImages && segment.imageObj) {
        const size = Math.min(radius * 0.22, 160);       
        const imgRadius = radius + size * 0.15;          

        const x = Math.cos(midAngle) * imgRadius;
        const y = Math.sin(midAngle) * imgRadius;

        ctx.save();
        ctx.translate(x, y);
        ctx.shadowColor = "rgba(0,0,0,0.35)";
        ctx.shadowBlur = 10;
        ctx.shadowOffsetY = 4;

        ctx.drawImage(segment.imageObj, -size/2, -size/2, size, size);

        ctx.restore();
      }
    });

    // Center circle + logo
    ctx.beginPath();
    ctx.arc(0, 0, centerRadius, 0, 2 * Math.PI);
    ctx.fillStyle = "#ffffff";
    ctx.fill();

    if (logoImg) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(0, 0, centerRadius - 6, 0, 2 * Math.PI);
      ctx.closePath();
      ctx.clip();

      const size = (centerRadius - 6) * 2;
      ctx.drawImage(logoImg, -size/2, -size/2, size, size);
      ctx.restore();
    }

    ctx.restore();
  }

  // ===== Spin logic =====
  function spin() {
    if (isSpinning || !segments.length) return;

    isSpinning = true;
    hideResultModal();
    wheelWrapper.classList.add("spin-anim");

    const spins = 4 + Math.random() * 3;
    const extraRotation = Math.random() * 2 * Math.PI;
    const startRotation = currentRotation;
    const targetRotation = startRotation + spins * 2 * Math.PI + extraRotation;
    const duration = 4000;
    const startTime = performance.now();

    function animate(now) {
      const elapsed = now - startTime;
      const t = Math.min(elapsed / duration, 1);
      const eased = 1 - Math.pow(1 - t, 3);

      currentRotation = startRotation + (targetRotation - startRotation) * eased;
      drawWheel(currentRotation);

      if (t < 1) {
        requestAnimationFrame(animate);
      } else {
        isSpinning = false;
        wheelWrapper.classList.remove("spin-anim");
        showWinner();
      }
    }
    requestAnimationFrame(animate);
  }

  function showWinner() {
    if (!segments.length) return;

    let rot = currentRotation % (2 * Math.PI);
    if (rot < 0) rot += 2 * Math.PI;

    const pointerAngleInWheel = (2 * Math.PI - rot) % (2 * Math.PI);
    let index = Math.floor(pointerAngleInWheel / sliceAngle);
    if (index === segments.length) index = 0;

    const segment = segments[index];

    resultTitleEl.textContent = "You got:";
    resultTextEl.textContent = segment.label;
    const linkAllowed = segment.linkEnabled !== false && segment.url && segment.url !== "#";
    resultLinkEl.href = linkAllowed ? segment.url : "#";
    resultLinkEl.classList.toggle("hidden", !linkAllowed);

    showResultModal();
    startConfettiBomb();
  }

  wheelWrapper.addEventListener("click", spin);

  // ===== Confetti BOMB =====
  function startConfettiBomb() {
    resizeConfettiCanvas();
    const width = confettiCanvas.width;
    const height = confettiCanvas.height;
    
    const count = 1500;
    const colors = ["#ff4b4b", "#ffd166", "#06d6a0", "#118ab2", "#ef476f", "#ffffff", "#FD5DA8"];
    
    confettiParticles = [];
    
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const velocity = 10 + Math.random() * 25; 

      confettiParticles.push({
        x: width / 2,
        y: height / 2,
        r: 3 + Math.random() * 6,
        color: colors[Math.floor(Math.random() * colors.length)],
        vx: Math.cos(angle) * velocity,
        vy: Math.sin(angle) * velocity,
        gravity: 0.5 + Math.random() * 0.2,
        drag: 0.92 + Math.random() * 0.05,
        rotation: Math.random() * 2 * Math.PI,
        vr: (Math.random() - 0.5) * 0.5
      });
    }

    const duration = 4500;
    const start = performance.now();

    function frame(now) {
      const elapsed = now - start;
      if (elapsed > duration) {
         confettiCtx.clearRect(0, 0, width, height);
         return;
      }

      confettiCtx.clearRect(0, 0, width, height);
      
      confettiParticles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += p.gravity;
        p.vx *= p.drag; 
        p.vy *= p.drag;
        p.rotation += p.vr;

        confettiCtx.save();
        confettiCtx.translate(p.x, p.y);
        confettiCtx.rotate(p.rotation);
        confettiCtx.fillStyle = p.color;
        
        if (p.r % 2 > 1) {
            confettiCtx.beginPath();
            confettiCtx.arc(0, 0, p.r, 0, 2 * Math.PI);
            confettiCtx.fill();
        } else {
            confettiCtx.fillRect(-p.r, -p.r, p.r * 2, p.r * 2);
        }
        
        confettiCtx.restore();
      });

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  }

  // ===== Logo & background uploads (COMPRESSED) =====
  
  logoInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) {
      logoImg = null;
      logoDataUrl = null;
      drawWheel(currentRotation);
      saveLocalState();
      return;
    }

    // Compress logo to max 300px width
    processImage(file, 300, 0.8).then(dataUrl => {
        logoDataUrl = dataUrl;
        const img = new Image();
        img.onload = () => {
          logoImg = img;
          drawWheel(currentRotation);
          saveLocalState();
        };
        img.onerror = () => {
             alert("Failed to load logo after processing. Please try a different file.");
             logoDataUrl = null;
             logoImg = null;
             drawWheel(currentRotation);
             saveLocalState();
        }
        img.src = logoDataUrl;
    }).catch(err => {
        console.error(err);
        alert("Image too large or invalid.");
    });
  });

  bgInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) {
      bgDataUrl = null;
      appEl.style.backgroundImage = "";
      saveLocalState();
      return;
    }

    // Compress background to max 1280px width, quality 0.7
    processImage(file, 1280, 0.7).then(dataUrl => {
        bgDataUrl = dataUrl;
        appEl.style.backgroundImage = `url(${bgDataUrl})`;
        saveLocalState();
    }).catch(err => {
        console.error(err);
        alert("Image too large or invalid.");
    });
  });

  // ===== Export / import config =====
  exportBtn.addEventListener("click", () => {
    const config = {
      segments: segments.map(s => ({
        label: s.label,
        url: s.url,
        color: s.color,
        imageDataUrl: s.imageDataUrl || null,
        linkEnabled: s.linkEnabled !== false
      })),
      showImages,
      logoDataUrl: logoDataUrl || null,
      backgroundDataUrl: bgDataUrl || null
    };

    const blob = new Blob([JSON.stringify(config, null, 2)], {
      type: "application/json"
    });

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    a.href = url;
    a.download = `wheel-config-${timestamp}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  });

  importBtn.addEventListener("click", () => {
    importInput.value = "";
    importInput.click();
  });

  importInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = () => {
      try {
        const data = JSON.parse(reader.result);
        loadConfig(data);
        saveLocalState();
      } catch (err) {
        console.error(err);
        alert("Could not read config file.");
      }
    };
    reader.readAsText(file);
  });

  function loadConfig(data) {
    if (typeof data !== "object" || data === null) return;

    if (Array.isArray(data.segments) && data.segments.length) {
      segments = data.segments.map((s, i) => ({
        label: s.label || `Prize ${i + 1}`,
        url: s.url || "#",
        color: s.color || colorPalette[i % colorPalette.length],
        imageDataUrl: s.imageDataUrl || null,
        imageObj: null,
        linkEnabled: s.linkEnabled !== false,
        collapsed: !!s.collapsed
      }));
    }

    if (!segments.length) return;

    showImages = data.showImages !== false;
    showImagesToggle.checked = showImages;

    if (data.wheelZoom) {
        setWheelZoom(data.wheelZoom);
    }

    ensureSliceAngle();
    renderSectorsPanel();

    let stateWasCleaned = false;
    const imageLoadPromises = [];

    // 1. Background (Synchronous CSS application, supports old + new keys)
    let backgroundData = null;
    if (typeof data.backgroundDataUrl === "string" && data.backgroundDataUrl.startsWith("data:")) {
      backgroundData = data.backgroundDataUrl;
    } else if (typeof data.bgDataUrl === "string" && data.bgDataUrl.startsWith("data:")) {
      backgroundData = data.bgDataUrl;
    }

    if (backgroundData) {
      bgDataUrl = backgroundData;
      appEl.style.backgroundImage = `url(${bgDataUrl})`;
    } else {
      bgDataUrl = null;
      appEl.style.backgroundImage = "";
    }

    // 2. Logo (Async with Promise for definitive state check)
    if (typeof data.logoDataUrl === "string" && data.logoDataUrl.startsWith("data:")) {
        logoDataUrl = data.logoDataUrl;
        imageLoadPromises.push(new Promise(resolve => {
            const img = new Image();
            img.onload = () => {
                logoImg = img;
                resolve();
            };
            img.onerror = () => {
                console.warn("Failed to load saved logo image. Clearing DataURL.");
                logoDataUrl = null; 
                logoImg = null;
                stateWasCleaned = true;
                resolve(); // Resolve even on error so Promise.all can continue
            }
            img.src = logoDataUrl;
        }));
    } else {
      logoDataUrl = null;
      logoImg = null;
    }

    // 3. Segment Images (Async with Promises for definitive state check)
    segments.forEach((s) => {
      if (s.imageDataUrl) {
        imageLoadPromises.push(new Promise(resolve => {
            const img = new Image();
            img.onload = () => {
                s.imageObj = img;
                resolve();
            };
            img.onerror = () => {
                console.warn(`Failed to load saved image for sector: ${s.label}. Clearing DataURL.`);
                s.imageDataUrl = null;
                s.imageObj = null;
                stateWasCleaned = true;
                resolve(); // Resolve even on error
            };
            img.src = s.imageDataUrl;
        }));
      }
    });

    // Wait for all image loading attempts
    Promise.all(imageLoadPromises).then(() => {
        drawWheel(currentRotation);
        if (stateWasCleaned) {
            console.log("One or more images failed to load, saving clean state to localStorage.");
            // Only save if we had to clean up a corrupted DataURL
            saveLocalState();
        }
    });

    // Initial draw of the wheel while images load
    drawWheel(currentRotation);
  }

  function loadDefault() {
      segments = defaultSegmentsData.map((s, i) => ({
      label: s.label,
      url: s.url,
      color: s.color || colorPalette[i % colorPalette.length],
      imageDataUrl: null,
      imageObj: null,
      linkEnabled: true,
      collapsed: false
    }));
    setWheelZoom(1);
    ensureSliceAngle();
    renderSectorsPanel();
  }

  // ===== Init =====
  async function init() {
    resizeConfettiCanvas();
    
    // 1. Try to load from Local Storage
    const saved = localStorage.getItem(LOCAL_STORAGE_KEY);
    if (saved) {
      try {
        const data = JSON.parse(saved);
        loadConfig(data);
      } catch(e) {
        console.error("Error loading saved state", e);
        loadDefault();
      }
    } else {
      loadDefault();
    }

    // 2. Load preset background image
    try {
      const bgResponse = await fetch('bg.png');
      if (bgResponse.ok) {
        const bgBlob = await bgResponse.blob();
        const reader = new FileReader();
        reader.onload = () => {
          bgDataUrl = reader.result;
          appEl.style.backgroundImage = `url(${bgDataUrl})`;
        };
        reader.readAsDataURL(bgBlob);
      }
    } catch(e) {
      console.log("No bg.png found in root, using default background");
    }

    // 3. Load preset logo image
    try {
      const logoResponse = await fetch('logo.png');
      if (logoResponse.ok) {
        const logoBlob = await logoResponse.blob();
        const reader = new FileReader();
        reader.onload = () => {
          logoDataUrl = reader.result;
          const img = new Image();
          img.onload = () => {
            logoImg = img;
            drawWheel(currentRotation);
          };
          img.src = logoDataUrl;
        };
        reader.readAsDataURL(logoBlob);
      }
    } catch(e) {
      console.log("No logo.png found in root, wheel will have no center logo");
    }

    try {
      if (document.fonts && document.fonts.load) {
        await document.fonts.load(FONT_SPEC);
      }
    } catch {}

    drawWheel(currentRotation);
  }

  init();
</script>
</body>
</html>
   
