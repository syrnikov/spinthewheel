<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Prize Wheel (IndexedDB persistence)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Same styles as before, condensed for brevity */
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Montserrat,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;background:#f5f5f9}
    .app{display:flex;gap:16px;padding:16px;max-width:1400px;margin:0 auto;width:100%}
    .wheel-area{flex:1;display:flex;align-items:center;justify-content:center}
    .wheel-wrapper{width:min(80vmin,700px);height:min(80vmin,700px);border-radius:50%;position:relative;cursor:pointer;overflow:visible}
    canvas{display:block;width:100%;height:100%}
    .panel{width:380px;background:rgba(255,255,255,0.97);border-radius:12px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,0.08);max-height:100vh;overflow:auto}
    .pointer{position:absolute;top:50%;right:-6px;width:0;height:0;border-top:18px solid transparent;border-bottom:18px solid transparent;border-right:28px solid #fff;filter:drop-shadow(0 2px 6px rgba(0,0,0,0.45));z-index:3}
    .sector-card{border-radius:10px;padding:8px;border:1px solid #eee;background:#fafafa;margin-bottom:8px}
    .hidden{display:none!important}
    #confettiCanvas{position:fixed;inset:0;pointer-events:none;z-index:900}
    .result-modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:1000}
    .result-modal__backdrop{position:absolute;inset:0;background:rgba(0,0,0,0.45)}
    .result-modal__content{position:relative;background:#fff;border-radius:12px;padding:20px;z-index:1;max-width:320px;text-align:center}
    @media (max-width:900px){.app{flex-direction:column}.panel{width:100%}}
  </style>
</head>
<body>
  <div class="app" id="appRoot">
    <div class="wheel-area" id="wheelArea">
      <div class="wheel-wrapper" id="wheelWrapper">
        <canvas id="wheelCanvas" width="1200" height="1200"></canvas>
        <div class="pointer"></div>
      </div>
    </div>

    <div class="panel" id="settingsPanel">
      <h2>Prize wheel</h2>
      <small>Click the wheel to spin. Changes save automatically.</small>

      <div style="margin-top:12px">
        <label style="display:flex;align-items:center;gap:8px;">
          <input type="checkbox" id="showImagesToggle" checked> Show prize images
        </label>
      </div>

      <div style="margin-top:12px">
        <label>Wheel zoom</label>
        <div style="display:flex;gap:8px;align-items:center">
          <button class="zoom-btn" data-delta="-0.05">−</button>
          <input type="range" id="zoomSlider" min="0.7" max="1.3" step="0.05" value="1" style="flex:1">
          <button class="zoom-btn" data-delta="0.05">+</button>
          <div id="zoomValue">100%</div>
        </div>
      </div>

      <div style="margin-top:12px">
        <div id="sectorsContainer"></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="addSectorBtn">+ Add sector</button>
          <button id="resetBtn" style="background:#ff4b4b;color:#fff;border:none;padding:6px 10px;border-radius:8px">Reset to Default</button>
        </div>
      </div>

      <div style="margin-top:12px">
        <label>Center logo (optional)</label>
        <input type="file" id="logoInput" accept="image/*">
      </div>

      <div style="margin-top:12px">
        <label>Background image (optional)</label>
        <input type="file" id="bgInput" accept="image/*">
      </div>

      <div style="margin-top:12px">
        <label>Config</label>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="exportBtn">Export config</button>
          <button id="importBtn">Import config</button>
        </div>
        <input type="file" id="importInput" accept="application/json" style="display:none">
      </div>

      <div style="margin-top:12px">
        <button id="fullscreenBtn">Fullscreen</button>
      </div>
    </div>

    <canvas id="confettiCanvas"></canvas>

    <div id="resultModal" class="result-modal hidden">
      <div class="result-modal__backdrop"></div>
      <div class="result-modal__content">
        <h3 id="resultTitle">You got:</h3>
        <p id="resultText"></p>
        <a id="resultLink" href="#" target="_blank" rel="noopener noreferrer">Open prize</a><br>
        <button id="resultClose">OK</button>
      </div>
    </div>
  </div>

<script>
/* -------------------------
   Config / Defaults
   -------------------------*/
const LOCAL_STORAGE_KEY = "prize_wheel_config";
const IMAGE_DB_NAME = "prize_wheel_images_v1";
const IMAGE_STORE_NAME = "images";

const defaultSegmentsData = [
  { label: "Blum hardware pack", url: "https://example.com/blum",  color: "#ff4b4b" },
  { label: "Hinge upgrade",      url: "https://example.com/hinges",color: "#ffb347" },
  { label: "Lighting pack",      url: "https://example.com/lighting", color: "#ffe66d" },
  { label: "Worktop voucher",    url: "https://example.com/worktop", color: "#7bd389" },
  { label: "Kitchen consult",    url: "https://example.com/consult", color: "#4f98ca" },
  { label: "Accessory set",      url: "https://example.com/accessories", color: "#b084f4" },
  { label: "Mystery prize",      url: "https://example.com/mystery", color: "#ff6fb5" }
];

const colorPalette = [
  "#ff4b4b", "#ffb347", "#ffe66d", "#7bd389",
  "#4f98ca", "#b084f4", "#ff6fb5", "#ffa3a3"
];

/* -------------------------
   DOM refs
   -------------------------*/
const appEl = document.getElementById("appRoot");
const wheelWrapper = document.getElementById("wheelWrapper");
const canvas = document.getElementById("wheelCanvas");
const ctx = canvas.getContext("2d");
const confettiCanvas = document.getElementById("confettiCanvas");
const confettiCtx    = confettiCanvas.getContext("2d");

const sectorsContainer = document.getElementById("sectorsContainer");
const addSectorBtn     = document.getElementById("addSectorBtn");
const resetBtn         = document.getElementById("resetBtn");
const showImagesToggle = document.getElementById("showImagesToggle");
const logoInput        = document.getElementById("logoInput");
const bgInput          = document.getElementById("bgInput");
const exportBtn        = document.getElementById("exportBtn");
const importBtn        = document.getElementById("importBtn");
const importInput      = document.getElementById("importInput");
const fullscreenBtn    = document.getElementById("fullscreenBtn");
const zoomSlider       = document.getElementById("zoomSlider");
const zoomValue        = document.getElementById("zoomValue");
const zoomButtons      = document.querySelectorAll(".zoom-btn");

const resultModal     = document.getElementById("resultModal");
const resultBackdrop  = resultModal.querySelector(".result-modal__backdrop");
const resultTitleEl   = document.getElementById("resultTitle");
const resultTextEl    = document.getElementById("resultText");
const resultLinkEl    = document.getElementById("resultLink");
const resultCloseBtn  = document.getElementById("resultClose");

/* -------------------------
   State
   -------------------------*/
let segments = [];
let showImages = true;
let wheelZoom = 1;
let logoImg = null;
let logoKey = null;    // IndexedDB key for logo
let bgKey = null;      // IndexedDB key for background
let currentRotation = 0;
let isSpinning = false;
let sliceAngle = 0;

/* -------------------------
   IndexedDB helpers
   -------------------------*/
function openImageDB() {
  return new Promise((resolve, reject) => {
    if (!window.indexedDB) {
      resolve(null); // fallback: no IndexedDB available
      return;
    }
    const req = indexedDB.open(IMAGE_DB_NAME, 1);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(IMAGE_STORE_NAME)) {
        db.createObjectStore(IMAGE_STORE_NAME);
      }
    };
    req.onsuccess = (e) => {
      resolve(e.target.result);
    };
    req.onerror = (e) => {
      console.warn("IndexedDB open error", req.error);
      resolve(null); // don't reject: degrade gracefully
    };
  });
}

function putImageToDB(key, dataUrl) {
  return new Promise(async (resolve, reject) => {
    const db = await openImageDB();
    if (!db) { resolve(false); return; }
    const tx = db.transaction(IMAGE_STORE_NAME, "readwrite");
    tx.objectStore(IMAGE_STORE_NAME).put(dataUrl, key);
    tx.oncomplete = () => { db.close(); resolve(true); };
    tx.onerror = () => { db.close(); console.warn("Failed to write image to DB", tx.error); resolve(false); };
  });
}

function getImageFromDB(key) {
  return new Promise(async (resolve) => {
    const db = await openImageDB();
    if (!db) { resolve(null); return; }
    const tx = db.transaction(IMAGE_STORE_NAME, "readonly");
    const req = tx.objectStore(IMAGE_STORE_NAME).get(key);
    req.onsuccess = () => {
      resolve(req.result || null);
      db.close();
    };
    req.onerror = () => {
      console.warn("Failed to read image from DB", req.error);
      resolve(null);
      db.close();
    };
  });
}

function deleteImageFromDB(key) {
  return new Promise(async (resolve) => {
    const db = await openImageDB();
    if (!db) { resolve(false); return; }
    const tx = db.transaction(IMAGE_STORE_NAME, "readwrite");
    tx.objectStore(IMAGE_STORE_NAME).delete(key);
    tx.oncomplete = () => { db.close(); resolve(true); };
    tx.onerror = () => { db.close(); resolve(false); };
  });
}

/* -------------------------
   Image processing helper (resize+compress)
   -------------------------*/
function processImage(file, maxWidth = 1200, quality = 0.8) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        let w = img.width;
        let h = img.height;
        if (w > maxWidth) {
          h = (h * maxWidth) / w;
          w = maxWidth;
        }
        const c = document.createElement('canvas');
        c.width = w;
        c.height = h;
        const cx = c.getContext('2d');
        cx.drawImage(img, 0, 0, w, h);
        const type = file.type === 'image/png' ? 'image/png' : 'image/jpeg';
        resolve(c.toDataURL(type, quality));
      };
      img.onerror = reject;
      img.src = e.target.result;
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

/* -------------------------
   Persistence: save/load config
   Uses localStorage for config (small) and IndexedDB for images
   -------------------------*/
async function saveLocalState() {
  const config = {
    segments: segments.map((s) => ({
      label: s.label,
      url: s.url,
      color: s.color,
      imageKey: s.imageKey || null,
      linkEnabled: s.linkEnabled !== false,
      collapsed: !!s.collapsed
    })),
    showImages,
    wheelZoom,
    logoKey: logoKey || null,
    backgroundKey: bgKey || null,
    // backwards compatibility (some older importers read this)
    bgDataUrl: null,
    backgroundDataUrl: null
  };

  try {
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(config));
  } catch (e) {
    console.warn("Could not write localStorage:", e);
    // don't throw, degrade gracefully
  }
}

async function loadFromLocalState() {
  const saved = localStorage.getItem(LOCAL_STORAGE_KEY);
  if (!saved) return false;
  try {
    const data = JSON.parse(saved);
    await loadConfig(data);
    return true;
  } catch (e) {
    console.warn("Failed to parse saved config", e);
    return false;
  }
}

/* -------------------------
   UI helpers: sector panel render and interactions
   -------------------------*/
function ensureSliceAngle() {
  sliceAngle = segments.length ? (2 * Math.PI) / segments.length : 0;
}

function renderSectorsPanel() {
  sectorsContainer.innerHTML = "";
  segments.forEach((seg, i) => {
    const card = document.createElement("div");
    card.className = "sector-card";
    card.dataset.index = i;
    const preview = seg.imageKey ? `background-image:url(${seg.imageDataUrl || ''})` : "background-image:none";
    card.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
        <div style="display:flex;align-items:center;gap:8px">
          <button class="drag-handle" title="Drag">☰</button>
          <strong>Sector ${i+1}</strong>
          <span style="width:10px;height:10px;border-radius:50%;background:${seg.color};display:inline-block;margin-left:8px"></span>
        </div>
        <div style="display:flex;gap:8px">
          <button class="collapse-toggle">${seg.collapsed ? '▸' : '▾'}</button>
          <button class="sector-delete"${segments.length<=1? ' disabled': ''}>✕</button>
        </div>
      </div>
      <div class="sector-body"${seg.collapsed? ' style="display:none"' : ''}>
        <div style="margin-bottom:6px">
          <label>Label</label>
          <input type="text" class="sector-label" value="${(seg.label||'').replace(/"/g,'&quot;')}" style="width:100%;padding:6px;border-radius:6px;border:1px solid #ddd">
        </div>
        <div style="margin-bottom:6px">
          <label>Link <label style="float:right"><input type="checkbox" class="sector-link-enabled" ${seg.linkEnabled !== false ? 'checked' : ''}></label></label>
          <input type="url" class="sector-url" value="${(seg.url||'#').replace(/"/g,'&quot;')}" style="width:100%;padding:6px;border-radius:6px;border:1px solid #ddd">
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <div style="width:40px;height:40px;border:1px solid #ddd;border-radius:6px;background-size:cover;background-position:center;${preview}"></div>
          <div style="flex:1">
            <label>Image</label>
            <input type="file" class="sector-image" accept="image/*">
          </div>
          <div>
            <input type="color" class="sector-color" value="${seg.color}">
          </div>
        </div>
      </div>
    `;
    sectorsContainer.appendChild(card);
  });
}

sectorsContainer.addEventListener("input", (e) => {
  const target = e.target;
  const card = target.closest(".sector-card");
  if (!card) return;
  const index = Number(card.dataset.index);
  const seg = segments[index];
  if (!seg) return;
  if (target.classList.contains("sector-label")) seg.label = target.value || `Prize ${index+1}`;
  if (target.classList.contains("sector-url")) seg.url = target.value || "#";
  if (target.classList.contains("sector-color")) seg.color = target.value || seg.color;
  drawWheel(currentRotation);
  saveLocalState();
});

sectorsContainer.addEventListener("change", async (e) => {
  const target = e.target;
  const card = target.closest(".sector-card");
  if (!card) return;
  const index = Number(card.dataset.index);
  const seg = segments[index];
  if (!seg) return;

  if (target.classList.contains("sector-link-enabled")) {
    seg.linkEnabled = target.checked;
    const urlInput = card.querySelector(".sector-url");
    if (urlInput) urlInput.disabled = !seg.linkEnabled;
    saveLocalState();
    drawWheel(currentRotation);
    return;
  }

  if (!target.classList.contains("sector-image")) return;
  const file = target.files[0];
  if (!file) {
    // remove image
    if (seg.imageKey) {
      await deleteImageFromDB(seg.imageKey);
      seg.imageKey = null;
    }
    seg.imageDataUrl = null;
    seg.imageObj = null;
    renderSectorsPanel();
    drawWheel(currentRotation);
    saveLocalState();
    return;
  }

  try {
    const dataUrl = await processImage(file, 800, 0.82);
    // create a stable key
    const key = `seg-${Date.now()}-${Math.floor(Math.random()*10000)}`;
    const ok = await putImageToDB(key, dataUrl);
    if (ok) {
      // delete old imageKey to avoid leak
      if (seg.imageKey) await deleteImageFromDB(seg.imageKey);
      seg.imageKey = key;
      seg.imageDataUrl = dataUrl;
      const img = new Image();
      img.onload = () => { seg.imageObj = img; drawWheel(currentRotation); };
      img.src = dataUrl;
      renderSectorsPanel();
      saveLocalState();
    } else {
      // fallback: keep in-memory dataUrl only (no DB)
      seg.imageDataUrl = dataUrl;
      seg.imageObj = new Image();
      seg.imageObj.src = dataUrl;
      saveLocalState();
    }
  } catch (err) {
    console.error("Failed to process sector image", err);
    alert("Failed to process image. Try a smaller file.");
  }
});

sectorsContainer.addEventListener("click", async (e) => {
  const target = e.target;
  if (target.classList.contains("sector-delete") && !target.disabled) {
    const card = target.closest(".sector-card");
    const idx = Number(card.dataset.index);
    const seg = segments[idx];
    if (seg && seg.imageKey) await deleteImageFromDB(seg.imageKey);
    segments.splice(idx, 1);
    ensureSliceAngle();
    renderSectorsPanel();
    drawWheel(currentRotation);
    saveLocalState();
  } else if (target.classList.contains("collapse-toggle")) {
    const card = target.closest(".sector-card");
    const idx = Number(card.dataset.index);
    const seg = segments[idx];
    seg.collapsed = !seg.collapsed;
    renderSectorsPanel();
    saveLocalState();
  }
});

/* -------------------------
   Add / reset
   -------------------------*/
function addSector(initial) {
  const base = initial || {};
  segments.push({
    label: base.label || `Prize ${segments.length + 1}`,
    url: base.url || "#",
    color: base.color || colorPalette[segments.length % colorPalette.length],
    imageKey: base.imageKey || null,
    imageDataUrl: base.imageDataUrl || null, // may be populated during load
    imageObj: base.imageObj || null,
    linkEnabled: base.linkEnabled !== false,
    collapsed: !!base.collapsed
  });
  ensureSliceAngle();
  renderSectorsPanel();
  drawWheel(currentRotation);
  saveLocalState();
}

addSectorBtn.addEventListener("click", () => addSector());

resetBtn.addEventListener("click", () => {
  if (!confirm("Reset to default? This clears saved config.")) return;
  localStorage.removeItem(LOCAL_STORAGE_KEY);
  // clear image DB as well
  (async () => {
    const db = await openImageDB();
    if (db) {
      const tx = db.transaction(IMAGE_STORE_NAME, "readwrite");
      tx.objectStore(IMAGE_STORE_NAME).clear();
      tx.oncomplete = () => { db.close(); location.reload(); };
      tx.onerror = () => { db.close(); location.reload(); };
    } else {
      location.reload();
    }
  })();
});

/* -------------------------
   Zoom controls
   -------------------------*/
const ZOOM_MIN = 0.7;
const ZOOM_MAX = 1.3;
function setWheelZoom(value) {
  const clamped = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, value));
  wheelZoom = clamped;
  wheelWrapper.style.transform = `scale(${clamped})`;
  zoomSlider.value = clamped.toFixed(2);
  zoomValue.textContent = `${Math.round(clamped * 100)}%`;
  saveLocalState();
}

zoomSlider.addEventListener("input", () => setWheelZoom(parseFloat(zoomSlider.value)));
zoomButtons.forEach(btn => btn.addEventListener("click", () => setWheelZoom(wheelZoom + parseFloat(btn.dataset.delta || "0"))));

/* -------------------------
   Fullscreen
   -------------------------*/
function toggleFullscreen() {
  const el = document.documentElement;
  if (!document.fullscreenElement) {
    el.requestFullscreen?.();
  } else {
    document.exitFullscreen?.();
  }
}
fullscreenBtn.addEventListener("click", toggleFullscreen);
document.addEventListener("fullscreenchange", () => {
  fullscreenBtn.textContent = document.fullscreenElement ? "Exit fullscreen" : "Fullscreen";
});

/* -------------------------
   Drawing the wheel
   -------------------------*/
function drawWheel(rotation) {
  if (!segments.length) return;
  const w = canvas.width;
  const h = canvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.save();
  const cx = w/2, cy = h/2;
  ctx.translate(cx, cy);
  const radius = Math.min(w, h)/2 - 80;
  const centerRadius = radius * 0.18;
  const textRadius = radius - 70;
  segments.forEach((s, i) => {
    const start = rotation + i * sliceAngle;
    const end = start + sliceAngle;
    const mid = start + sliceAngle / 2;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.arc(0,0,radius,start,end);
    ctx.closePath();
    ctx.fillStyle = s.color;
    ctx.fill();

    ctx.save();
    ctx.rotate(mid);
    ctx.textAlign = "right";
    ctx.font = `600 26px 'Montserrat', system-ui`;
    const textWidth = ctx.measureText(s.label).width;
    const maxW = textRadius - (centerRadius + 30);
    if (maxW > 0 && textWidth > maxW) {
      const scale = maxW / textWidth;
      const newSize = Math.max(14, Math.floor(26 * scale));
      ctx.font = `600 ${newSize}px 'Montserrat', system-ui`;
    }
    ctx.fillStyle = (getReadableTextColor(s.color));
    ctx.fillText(s.label, textRadius, 10);
    ctx.restore();

    if (showImages && (s.imageObj || s.imageDataUrl)) {
      const size = Math.min(radius * 0.22, 160);
      const imgRadius = radius + size * 0.16;
      const x = Math.cos(mid) * imgRadius;
      const y = Math.sin(mid) * imgRadius;
      ctx.save();
      ctx.translate(x, y);
      ctx.shadowColor = "rgba(0,0,0,0.25)";
      ctx.shadowBlur = 8;
      const img = s.imageObj;
      if (img && img.complete) {
        ctx.drawImage(img, -size/2, -size/2, size, size);
      } else if (s.imageDataUrl) {
        const temp = new Image();
        temp.onload = () => { s.imageObj = temp; drawWheel(currentRotation); };
        temp.src = s.imageDataUrl;
      }
      ctx.restore();
    }
  });

  // center circle
  ctx.beginPath();
  ctx.arc(0,0,centerRadius,0,Math.PI*2);
  ctx.fillStyle = "#fff";
  ctx.fill();
  if (logoImg) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(0,0,centerRadius-6,0,Math.PI*2);
    ctx.clip();
    const size = (centerRadius-6) * 2;
    ctx.drawImage(logoImg, -size/2, -size/2, size, size);
    ctx.restore();
  }
  ctx.restore();
}

function getReadableTextColor(bg) {
  // quick accessible contrast guess
  try {
    const c = document.createElement("span");
    c.style.color = bg;
    document.body.appendChild(c);
    const rgb = getComputedStyle(c).color;
    document.body.removeChild(c);
    const m = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
    if (!m) return "#000";
    const r = m[1]/255, g = m[2]/255, b = m[3]/255;
    const L = 0.2126*Math.pow(r<=0.03928? r/12.92: Math.pow((r+0.055)/1.055,2.4),1)
            + 0.7152*Math.pow(g<=0.03928? g/12.92: Math.pow((g+0.055)/1.055,2.4),1)
            + 0.0722*Math.pow(b<=0.03928? b/12.92: Math.pow((b+0.055)/1.055,2.4),1);
    return L > 0.6 ? "#000" : "#fff";
  } catch { return "#000"; }
}

/* -------------------------
   Spin logic & result modal
   -------------------------*/
function spin() {
  if (isSpinning || !segments.length) return;
  isSpinning = true;
  wheelWrapper.classList.add("spin-anim");
  const spins = 4 + Math.random()*3;
  const extra = Math.random()*Math.PI*2;
  const start = currentRotation;
  const target = start + spins*2*Math.PI + extra;
  const dur = 4000;
  const t0 = performance.now();
  function step(now) {
    const t = Math.min(1, (now - t0)/dur);
    const eased = 1 - Math.pow(1-t,3);
    currentRotation = start + (target - start)*eased;
    drawWheel(currentRotation);
    if (t < 1) requestAnimationFrame(step);
    else {
      isSpinning = false;
      wheelWrapper.classList.remove("spin-anim");
      showWinner();
    }
  }
  requestAnimationFrame(step);
}

wheelWrapper.addEventListener("click", spin);

function showWinner() {
  let rot = currentRotation % (2*Math.PI);
  if (rot < 0) rot += 2*Math.PI;
  const pointerAngle = (2*Math.PI - rot) % (2*Math.PI);
  let index = Math.floor(pointerAngle / sliceAngle);
  if (index === segments.length) index = 0;
  const seg = segments[index];
  resultTitleEl.textContent = "You got:";
  resultTextEl.textContent = seg.label;
  const allowed = seg.linkEnabled !== false && seg.url && seg.url !== "#";
  resultLinkEl.href = allowed ? seg.url : "#";
  resultLinkEl.classList.toggle("hidden", !allowed);
  resultModal.classList.remove("hidden");
  startConfettiBomb();
}

resultCloseBtn.addEventListener("click", () => resultModal.classList.add("hidden"));
resultBackdrop.addEventListener("click", () => resultModal.classList.add("hidden"));

/* -------------------------
   Confetti (same as before)
   -------------------------*/
function resizeConfettiCanvas() { confettiCanvas.width = window.innerWidth; confettiCanvas.height = window.innerHeight; }
window.addEventListener("resize", resizeConfettiCanvas);

/* simple confetti blast */
function startConfettiBomb() {
  resizeConfettiCanvas();
  const width = confettiCanvas.width, height = confettiCanvas.height;
  let particles = [];
  for (let i=0;i<250;i++){
    particles.push({
      x: width/2 + (Math.random()-0.5)*200,
      y: height/2 + (Math.random()-0.5)*200,
      vx: (Math.random()-0.5)*20,
      vy: (Math.random()-1.5)*20,
      r: 3 + Math.random()*7,
      rot: Math.random()*Math.PI*2,
      vr: (Math.random()-0.5)*0.2,
      color: ["#ff4b4b","#ffd166","#06d6a0","#118ab2","#ef476f","#fff","#FD5DA8"][Math.floor(Math.random()*7)]
    });
  }
  const start = performance.now();
  function frame(now) {
    const t = now - start;
    confettiCtx.clearRect(0,0,width,height);
    particles.forEach(p => {
      p.x += p.vx; p.y += p.vy; p.vy += 0.3; p.vx *= 0.995; p.vy *= 0.995; p.rot += p.vr;
      confettiCtx.save();
      confettiCtx.translate(p.x,p.y);
      confettiCtx.rotate(p.rot);
      confettiCtx.fillStyle = p.color;
      confettiCtx.fillRect(-p.r/2,-p.r/2,p.r,p.r);
      confettiCtx.restore();
    });
    if (t < 2500) requestAnimationFrame(frame);
    else confettiCtx.clearRect(0,0,width,height);
  }
  requestAnimationFrame(frame);
}

/* -------------------------
   Logo & background upload (now writes to IndexedDB and uses keys)
   -------------------------*/
logoInput.addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) {
    // remove logo
    if (logoKey) { await deleteImageFromDB(logoKey); logoKey = null; }
    logoImg = null;
    saveLocalState();
    drawWheel(currentRotation);
    return;
  }
  try {
    const dataUrl = await processImage(file, 500, 0.85); // logos don't need to be huge
    const key = `logo-${Date.now()}-${Math.floor(Math.random()*10000)}`;
    const ok = await putImageToDB(key, dataUrl);
    if (ok) {
      if (logoKey) await deleteImageFromDB(logoKey);
      logoKey = key;
    } else {
      // fallback: keep in-memory only
      logoKey = null;
    }
    const img = new Image();
    img.onload = () => { logoImg = img; drawWheel(currentRotation); };
    img.src = dataUrl;
    // keep small in-memory copy for immediate drawing
    logoImg = new Image(); logoImg.src = dataUrl;
    saveLocalState();
  } catch (err) {
    console.error(err);
    alert("Failed to process logo. Try a smaller file.");
  }
});

bgInput.addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) {
    if (bgKey) { await deleteImageFromDB(bgKey); bgKey = null; }
    appEl.style.backgroundImage = "";
    saveLocalState();
    return;
  }
  try {
    const dataUrl = await processImage(file, 1280, 0.75);
    const key = `bg-${Date.now()}-${Math.floor(Math.random()*10000)}`;
    const ok = await putImageToDB(key, dataUrl);
    if (ok) {
      if (bgKey) await deleteImageFromDB(bgKey);
      bgKey = key;
    } else {
      bgKey = null;
    }
    appEl.style.backgroundImage = `url(${dataUrl})`;
    saveLocalState();
  } catch (err) {
    console.error(err);
    alert("Failed to process background. Try a smaller file.");
  }
});

/* -------------------------
   Export / import
   Export collects image DataURLs from DB and embeds them so exported JSON is portable
   -------------------------*/
exportBtn.addEventListener("click", async () => {
  try {
    const config = {
      segments: [],
      showImages,
      wheelZoom,
      logoDataUrl: null,
      backgroundDataUrl: null
    };

    // fetch logo + bg from DB (or in-memory)
    if (logoKey) {
      const d = await getImageFromDB(logoKey);
      config.logoDataUrl = d || null;
    } else if (logoImg && logoImg.src && logoImg.src.startsWith("data:")) {
      config.logoDataUrl = logoImg.src;
    } else { config.logoDataUrl = null; }

    if (bgKey) {
      const d = await getImageFromDB(bgKey);
      config.backgroundDataUrl = d || null;
    } else {
      // attempt to read inline background from style
      const bg = (appEl.style.backgroundImage || "").replace(/^url\(|\)$/g, '');
      config.backgroundDataUrl = (bg && bg.startsWith("data:")) ? bg : null;
    }

    // segments: get images from DB where present
    for (let i=0;i<segments.length;i++){
      const s = segments[i];
      let imageDataUrl = null;
      if (s.imageKey) imageDataUrl = await getImageFromDB(s.imageKey);
      else if (s.imageDataUrl) imageDataUrl = s.imageDataUrl;
      config.segments.push({
        label: s.label,
        url: s.url,
        color: s.color,
        imageDataUrl: imageDataUrl || null,
        linkEnabled: s.linkEnabled !== false
      });
    }

    const blob = new Blob([JSON.stringify(config, null, 2)], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `wheel-config-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } catch (err) {
    console.error("Export failed", err);
    alert("Export failed. See console.");
  }
});

importBtn.addEventListener("click", () => importInput.click());

importInput.addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  try {
    const txt = await file.text();
    const obj = JSON.parse(txt);
    await loadConfig(obj);
    saveLocalState();
    alert("Config imported.");
  } catch (err) {
    console.error(err);
    alert("Failed to import config.");
  }
});

/* -------------------------
   loadConfig: supports both embedded DataURLs and keys
   -------------------------*/
async function loadConfig(data) {
  if (!data) return;
  // segments
  if (Array.isArray(data.segments) && data.segments.length) {
    segments = data.segments.map((s, i) => ({
      label: s.label || `Prize ${i+1}`,
      url: s.url || "#",
      color: s.color || colorPalette[i % colorPalette.length],
      imageKey: s.imageKey || null,
      imageDataUrl: s.imageDataUrl || null, // present if import JSON contained the image inline
      imageObj: null,
      linkEnabled: s.linkEnabled !== false,
      collapsed: !!s.collapsed
    }));
  } else {
    // load defaults
    segments = defaultSegmentsData.map((s,i) => ({
      label: s.label, url: s.url, color: s.color || colorPalette[i%colorPalette.length],
      imageKey: null, imageDataUrl: null, imageObj: null, linkEnabled: true, collapsed:false
    }));
  }

  showImages = data.showImages !== false;
  showImagesToggle.checked = showImages;
  if (data.wheelZoom) setWheelZoom(data.wheelZoom);

  // background: if data.backgroundDataUrl present -> save to DB
  if (data.backgroundDataUrl) {
    const key = `bg-import-${Date.now()}`;
    const ok = await putImageToDB(key, data.backgroundDataUrl);
    if (ok) bgKey = key;
    else {
      bgKey = null;
      appEl.style.backgroundImage = `url(${data.backgroundDataUrl})`;
    }
  } else if (data.bgDataUrl) {
    // old key name support
    const key = `bg-import-${Date.now()}`;
    const ok = await putImageToDB(key, data.bgDataUrl);
    if (ok) bgKey = key;
    else { bgKey = null; appEl.style.backgroundImage = `url(${data.bgDataUrl})`; }
  } else if (data.backgroundKey) {
    // if config stores a DB key (rare), use it
    bgKey = data.backgroundKey;
    if (!bgKey) appEl.style.backgroundImage = "";
  } else {
    // try localStorage field (older)
    bgKey = data.backgroundKey || null;
    if (!bgKey) appEl.style.backgroundImage = "";
  }

  // logo
  if (data.logoDataUrl) {
    const key = `logo-import-${Date.now()}`;
    const ok = await putImageToDB(key, data.logoDataUrl);
    if (ok) {
      logoKey = key;
      const img = new Image();
      img.onload = () => { logoImg = img; drawWheel(currentRotation); };
      img.src = data.logoDataUrl;
    } else {
      logoKey = null;
      const img = new Image();
      img.onload = () => { logoImg = img; drawWheel(currentRotation); };
      img.src = data.logoDataUrl;
    }
  } else if (data.logoKey) {
    logoKey = data.logoKey;
  } else {
    logoKey = null;
  }

  // load images for segments from DB where possible
  for (let i=0;i<segments.length;i++){
    const s = segments[i];
    if (s.imageKey) {
      const d = await getImageFromDB(s.imageKey);
      if (d) { s.imageDataUrl = d; const img = new Image(); img.onload = () => { s.imageObj = img; drawWheel(currentRotation); }; img.src = d; }
      else s.imageDataUrl = null;
    } else if (s.imageDataUrl) {
      // the imported JSON contained the image inline, attempt to persist to DB
      const key = `seg-import-${Date.now()}-${i}`;
      const ok = await putImageToDB(key, s.imageDataUrl);
      if (ok) {
        s.imageKey = key;
        const img = new Image(); img.onload = () => { s.imageObj = img; drawWheel(currentRotation); }; img.src = s.imageDataUrl;
      } else {
        const img = new Image(); img.onload = () => { s.imageObj = img; drawWheel(currentRotation); }; img.src = s.imageDataUrl;
      }
    }
  }

  // if we have keys for logo/bg, pull them and apply
  if (bgKey) {
    const d = await getImageFromDB(bgKey);
    if (d) appEl.style.backgroundImage = `url(${d})`;
    else appEl.style.backgroundImage = "";
  } else {
    // if previously set via backgroundDataUrl we already applied it above
  }

  if (logoKey) {
    const d = await getImageFromDB(logoKey);
    if (d) {
      logoImg = new Image();
      logoImg.onload = () => drawWheel(currentRotation);
      logoImg.src = d;
    }
  }

  ensureSliceAngle();
  renderSectorsPanel();
  drawWheel(currentRotation);
}

/* -------------------------
   Initialization
   -------------------------*/
function loadDefault() {
  segments = defaultSegmentsData.map((s,i) => ({
    label: s.label, url: s.url, color: s.color || colorPalette[i%colorPalette.length],
    imageKey: null, imageDataUrl: null, imageObj: null, linkEnabled: true, collapsed: false
  }));
  ensureSliceAngle();
  renderSectorsPanel();
  setWheelZoom(1);
}

async function init() {
  resizeConfettiCanvas();

  // first try to load from localStorage
  const ok = await loadFromLocalState();
  if (!ok) {
    // if nothing saved, load defaults
    loadDefault();
  } else {
    // after loading from config, also ensure background/logo pulled from DB
    if (bgKey) {
      const d = await getImageFromDB(bgKey);
      if (d) appEl.style.backgroundImage = `url(${d})`;
      else appEl.style.backgroundImage = "";
    }
    if (logoKey) {
      const d = await getImageFromDB(logoKey);
      if (d) { logoImg = new Image(); logoImg.onload = () => drawWheel(currentRotation); logoImg.src = d; }
    }
  }
  drawWheel(currentRotation);
}

init();

</script>
</body>
</html>
